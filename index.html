<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Double Knitting Pattern Generator</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- html2canvas CDN for converting the rendered HTML to image (for download/copy) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Chosen Palette: Warm Neutrals with Subtle Indigo/Green/Red Accents -->
  <!-- Application Structure Plan: The application uses a three-column dashboard-like structure for its main content (Front Chart, Back Chart, Combined Chart). This allows users to simultaneously view their input patterns and the generated output, fostering direct comparison and immediate feedback. Controls for dimensions, zoom, and chart actions are positioned at the top for easy access. This structure was chosen for its intuitive visual flow, enabling users to easily explore the interactive data (pattern toggling) and synthesize the results (combined chart). -->
  <!-- Visualization & Content Choices:
    - Report Info -> Goal -> Viz/Presentation Method -> Interaction -> Justification -> Library/Method
    - Chart Data -> Inform/Design -> Interactive Grids (HTML Divs with dynamic classes) -> Cell click to toggle color -> Direct manipulation, visual feedback -> Vanilla JS
    - Combined Pattern Logic -> Inform/Synthesize -> Combined Chart (HTML Divs with dynamic classes and nested spans for dots) -> Auto-generated on input change -> Immediate visualization of complex logic -> Vanilla JS
    - Pattern Control -> Control -> Numeric Inputs (HTML Input) -> Input change for dimension update -> Precise control over grid size -> Vanilla JS
    - Zoom Control -> Explore/Context -> Buttons (HTML Button) -> Click to adjust cell size -> Adaptability for detail/overview -> Vanilla JS, CSS Variables
    - Image Download/Copy -> Output -> Buttons (HTML Button) -> Click to save/copy image -> User utility, sharing -> Canvas API (for dots), html2canvas (for overall capture)
    - Restart -> Control -> Button (HTML Button) -> Click to reset patterns -> User convenience -> Vanilla JS
    - Chart Labeling -> Inform -> Column/Row Numbers (HTML Divs/Spans directly in grid) -> Dynamically rendered, respond to zoom -> Improved clarity for knitting patterns (right-to-left, bottom-to-top for rows, right-to-left for cols at bottom) -> Vanilla JS
    - Information Architecture is designed to be highly interactive and task-oriented, allowing direct manipulation of input and immediate viewing of output.
  -->
  <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    /* Hide scrollbar for grid containers */
    .overflow-y-auto::-webkit-scrollbar {
      display: none;
    }
    .overflow-y-auto {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    /* Custom styles for grid cells - initial size will be set by JS */
    :root {
        --cell-size: 24px; /* Default cell size */
        --dot-size: 12px; /* Default dot size, half of cell-size */
        --dot-font-size: 0.75rem; /* text-xs for dots */
        --number-font-size: 0.7rem; /* Font size for row/col numbers */
    }
    .grid-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid #9ca3af; /* Equivalent to border border-gray-400 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      display: flex; /* Use flex to center content */
      align-items: center; /* Center vertically */
      justify-content: center; /* Center horizontally */
      position: relative; /* For absolute positioning of dot-container */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      overflow: hidden; /* Hide anything outside the cell */
    }
    .grid-cell-editable:hover {
      opacity: 0.75;
      cursor: pointer;
    }
    .bg-black { background-color: #000; }
    .bg-white { background-color: #fff; }
    .bg-gray-200 { background-color: #e5e7eb; } /* Fallback/initial color */
    .text-white { color: #fff; }
    .text-black { color: #000; }
    .border-gray-500 { border-color: #6b7280; }

    /* Styles for the message box */
    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #333;
        color: #fff;
        padding: 15px 30px;
        border-radius: 8px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        font-weight: 600;
        text-align: center;
    }
    .message-box.show {
        opacity: 1;
    }

    /* Improved centering for dots using absolute positioning */
    .grid-cell .dot-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Centering trick */
        width: var(--dot-size);
        height: var(--dot-size);
        line-height: var(--dot-size); /* Ensure text is vertically centered within its own box */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 9999px; /* rounded-full */
        border: 1px solid #6b7280; /* border-gray-500 */
        font-size: var(--dot-font-size);
        box-sizing: border-box; /* Include border in size */
    }

    /* Styles for number headers */
    .number-header {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--number-font-size); /* Now scales with zoom */
        color: #4b5563; /* gray-700 */
        font-weight: 600;
        box-sizing: border-box;
    }
    /* Specific styling for the top-left blank corner of the grid */
    .corner-header {
      width: var(--cell-size);
      height: var(--cell-size);
    }
    .chart-grid-container {
      display: grid;
      gap: 1px; /* Equivalent to gap-px */
      background-color: #d1d5db; /* Equivalent to bg-gray-300 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      max-height: 400px;
      overflow: auto; /* Use auto for scrolling content, not hidden */
      overflow-y: auto; /* Scroll for height */
      overflow-x: auto; /* Scroll for width if content exceeds */
    }
    /* Hide scrollbar for the specific grid containers */
    .chart-grid-container::-webkit-scrollbar {
        display: none;
    }
    .chart-grid-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-100 to-indigo-200 p-8 font-inter text-gray-800">
  <h1 class="text-4xl font-bold text-center mb-10 text-indigo-800 drop-shadow-lg">
    Double Knitting Pattern Generator
  </h1>

  <!-- Global Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mb-8 space-y-4 md:space-y-0 md:space-x-4">
    <!-- Grid Dimension Controls -->
    <div class="flex items-center space-x-4">
      <label for="rows" class="font-medium text-lg">Rows:</label>
      <input
        type="number"
        id="rows"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
      <label for="cols" class="font-medium text-lg">Columns:</label>
      <input
        type="number"
        id="cols"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
    </div>

    <!-- Zoom Controls -->
    <div class="flex items-center space-x-4">
      <span class="font-medium text-lg">Zoom:</span>
      <button id="zoomOutBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom Out
      </button>
      <button id="zoomInBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom In
      </button>
    </div>
  </div>

  <!-- Chart Display Area -->
  <div class="flex flex-wrap justify-center items-start">
    <!-- Front Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Front Chart (Click to toggle color)</h3>
      <div id="frontChartGrid" class="chart-grid-container"></div>
      <button id="inverseFrontBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Front Colors
      </button>
    </div>

    <!-- Back Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Back Chart (Click to toggle color)</h3>
      <div id="backChartGrid" class="chart-grid-container"></div>
      <button id="inverseBackBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Back Colors
      </button>
    </div>

    <!-- Combined Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Combined Chart (Read-Only)</h3>
      <div id="combinedChartGrid" class="chart-grid-container"></div>
    </div>
  </div>

  <!-- Download/Copy/Restart Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mt-8 space-y-4 md:space-y-0 md:space-x-4">
    <button id="downloadChartBtn" class="px-6 py-3 bg-green-500 text-white font-semibold rounded-md shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Combined Chart (PNG)
    </button>
    <button id="copyChartBtn" class="px-6 py-3 bg-blue-500 text-white font-semibold rounded-md shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Copy Combined Chart (Image)
    </button>
    <button id="restartBtn" class="px-6 py-3 bg-red-500 text-white font-semibold rounded-md shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Restart Charts
    </button>
  </div>

  <div class="text-center mt-10 p-4 bg-white rounded-lg shadow-lg max-w-2xl mx-auto">
    <h2 class="text-2xl font-semibold mb-4 text-indigo-700">Understanding the Combined Chart:</h2>
    <p class="text-gray-700 mb-2">
      This version of the combined chart uses simple color codes:
    </p>
    <ul class="list-disc list-inside text-left text-gray-600 mx-auto w-fit">
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Black cell with White dot (⚪):</span> Front is Black, Back is White. (e.g., Knit with Black yarn, Purl with White yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">White cell with Black dot (⚫):</span> Front is White, Back is Black. (e.g., Knit with White yarn, Purl with Black yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure Black cell:</span> Both Front and Back are Black. (e.g., Knit with Black, Purl with Black)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure White cell:</span> Both Front and Back are White. (e.g., Knit with White, Purl with White)</li>
    </ul>
    <p class="text-gray-700 mt-4">
      The dot representation on the combined chart clarifies the individual knit and purl stitches when the front and back patterns differ.
    </p>
  </div>

  <!-- Message box for copy/download feedback -->
  <div id="messageBox" class="message-box hidden"></div>

  <script>
    let rows = 20;
    let cols = 20;
    let frontChart = [];
    let backChart = [];
    let combinedChart = [];
    let currentCellSize = 24; // Initial cell size in pixels
    let currentDotSize = 12; // Initial dot size, half of cell-size
    let currentDotFontSize = 0.75; // Initial font size in rem for dots
    let currentNumberFontSize = '0.7rem'; // Initial font size for numbers

    const MIN_CELL_SIZE = 8;
    const MAX_CELL_SIZE = 60;
    const ZOOM_STEP = 4; // Pixel step for cell size

    const frontChartGridElement = document.getElementById('frontChartGrid');
    const backChartGridElement = document.getElementById('backChartGrid');
    const combinedChartGridElement = document.getElementById('combinedChartGrid');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const downloadChartBtn = document.getElementById('downloadChartBtn');
    const copyChartBtn = document.getElementById('copyChartBtn');
    const restartBtn = document.getElementById('restartBtn');
    const inverseFrontBtn = document.getElementById('inverseFrontBtn');
    const inverseBackBtn = document.getElementById('inverseBackBtn');
    const messageBox = document.getElementById('messageBox');

    function showMessage(message, duration = 3000) {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden');
        messageBox.classList.add('show');
        setTimeout(() => {
            messageBox.classList.remove('show');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 500);
        }, duration);
    }

    function createEmptyChart(r, c, startBlack = false) {
      return Array(r).fill(null).map(() => Array(c).fill(startBlack));
    }

    function initializeChartData() {
        frontChart = createEmptyChart(rows, cols, false); // Front starts white
        backChart = createEmptyChart(rows, cols, true); // Back starts black
        console.log('Chart data initialized.');
    }

    // Function to render an entire chart grid, including headers
    function renderChart(chartData, containerElementId, enableEdit, chartType) {
        const containerElement = document.getElementById(containerElementId);
        containerElement.innerHTML = ''; // Clear existing cells

        // Set grid template columns: 1 for row numbers, then 'cols' for pattern cells
        containerElement.style.gridTemplateColumns = `var(--cell-size) repeat(${cols}, var(--cell-size))`;
        // Set grid template rows: 'rows' for pattern cells, then 1 for column numbers
        containerElement.style.gridTemplateRows = `repeat(${rows}, var(--cell-size)) var(--cell-size)`;

        // --- Render Main Pattern Area and Row Headers ---
        for (let r = rows; r >= 1; r--) { // Loop for rows (Bottom to Top for numbering)
            // Row Header (first column of this logical row)
            const rowHeader = document.createElement('div');
            rowHeader.classList.add('number-header');
            rowHeader.textContent = r; // Display r (1-indexed)
            containerElement.appendChild(rowHeader);

            // Pattern Cells for this row
            for (let c = 1; c <= cols; c++) { // Loop for columns (Left to Right for drawing)
                const cellDiv = document.createElement('div');
                cellDiv.classList.add('grid-cell');
                // Store 0-indexed row/col for internal data array reference
                cellDiv.dataset.patternRow = r - 1; // 0-indexed row for internal data
                cellDiv.dataset.patternCol = c - 1; // 0-indexed col for internal data

                if (enableEdit) {
                    cellDiv.classList.add('grid-cell-editable');
                    cellDiv.addEventListener('click', () => toggleCell(chartType, r - 1, c - 1));
                }

                // Set initial color for front/back charts based on their data
                if (chartType === 'front') {
                    cellDiv.classList.add(frontChart[r - 1][c - 1] ? 'bg-black' : 'bg-white');
                } else if (chartType === 'back') {
                    cellDiv.classList.add(backChart[r - 1][c - 1] ? 'bg-black' : 'bg-white');
                }
                // Combined chart cells will be updated by generateAndRenderCombinedChart after their initial render
                containerElement.appendChild(cellDiv);
            }
        }

        // --- Render Bottom Row: Blank Corner + Column Headers ---
        // Blank bottom-left corner cell (occupies the space of the row number in the bottom row)
        const bottomLeftCornerDiv = document.createElement('div');
        bottomLeftCornerDiv.classList.add('corner-header');
        containerElement.appendChild(bottomLeftCornerDiv);

        // Column headers (Right to Left: cols, cols-1, ..., 1)
        for (let c = cols; c >= 1; c--) {
            const colHeader = document.createElement('div');
            colHeader.classList.add('number-header');
            colHeader.textContent = c; // Display c (1-indexed)
            containerElement.appendChild(colHeader);
        }
    }

    function toggleCell(chartType, patternRIdx, patternCIdx) {
      console.log(`Toggling cell [${patternRIdx}, ${patternCIdx}] in ${chartType} chart.`);
      let targetChart;
      let targetElementId;

      if (chartType === 'front') {
        targetChart = frontChart;
        targetElementId = 'frontChartGrid';
      } else if (chartType === 'back') {
        targetChart = backChart;
        targetElementId = 'backChartGrid';
      }

      targetChart[patternRIdx][patternCIdx] = !targetChart[patternRIdx][patternCIdx];
      // Update the specific cell's color in the DOM
      const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${patternRIdx}"][data-pattern-col="${patternCIdx}"]`);
      if (cellDiv) {
          cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
          cellDiv.classList.add(targetChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
      }
      generateAndRenderCombinedChart();
    }

    function generateAndRenderCombinedChart() {
      console.log('Generating and rendering combined chart...');
      combinedChart = frontChart.map((frontRow, rIdx) =>
        frontRow.map((frontCell, cIdx) => {
          const backCell = backChart[rIdx][cIdx];

          if (frontCell && !backCell) { // Front Black, Back White
            return 'BW';
          } else if (!frontCell && backCell) { // Front White, Back Black
            return 'WB';
          } else if (frontCell && backCell) { // Both Black
            return 'BB';
          } else { // Both White
            return 'WW';
          }
        })
      );
      console.log('New Combined Chart Data (for DOM render):', combinedChart);

      combinedChart.forEach((row, rIdx) => { // rIdx, cIdx here are 0-indexed for pattern data
        row.forEach((cellValue, cIdx) => {
          // Find the specific cell by its data attributes
          const cellDiv = combinedChartGridElement.querySelector(`[data-pattern-row="${rIdx}"][data-pattern-col="${cIdx}"]`);
          if (cellDiv) {
            let backgroundColorClass = 'bg-gray-200';
            let dotContentHTML = '';

            if (cellValue === 'BB' || cellValue === 'BW') {
              backgroundColorClass = 'bg-black';
            } else if (cellValue === 'WW' || cellValue === 'WB') {
              backgroundColorClass = 'bg-white';
            }

            cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
            cellDiv.classList.add(backgroundColorClass);

            if (cellValue === 'BW') {
              dotContentHTML = '<span class="dot-container text-white">⚪</span>';
            } else if (cellValue === 'WB') {
              dotContentHTML = '<span class="dot-container text-black">⚫</span>';
            }
            cellDiv.innerHTML = dotContentHTML; // Set innerHTML with the dot span
          }
        });
      });
      console.log('Combined Chart rendered to DOM.');
    }

    function updateZoom(factor) {
        let newSize = currentCellSize + (factor * ZOOM_STEP);
        newSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, newSize));

        if (newSize !== currentCellSize) {
            currentCellSize = newSize;
            currentDotSize = Math.max(8, Math.round(currentCellSize / 2));
            currentDotFontSize = Math.max(0.5, currentCellSize / 32);
            currentNumberFontSize = `${Math.max(0.6, currentCellSize / 35)}rem`; // Adjust number font size

            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
            document.documentElement.style.setProperty('--dot-size', `${currentDotSize}px`);
            document.documentElement.style.setProperty('--dot-font-size', `${currentDotFontSize}rem`);
            document.documentElement.style.setProperty('--number-font-size', currentNumberFontSize);
        }

        // Re-render all charts to apply new cell size, dot, and number styles, preserving data
        renderChart(frontChart, 'frontChartGrid', true, 'front');
        renderChart(backChart, 'backChartGrid', true, 'back');
        renderChart(combinedChart, 'combinedChartGrid', false, 'combined'); // Explicitly render combined chart grid
        generateAndRenderCombinedChart(); // Re-render combined with current data
        console.log(`Zoom updated to cell size: ${currentCellSize}px, dot size: ${currentDotSize}px, font size: ${currentDotFontSize}rem, number font size: ${currentNumberFontSize}.`);
    }

    function drawCombinedChartToCanvas() {
        const canvas = document.createElement('canvas');
        const renderScale = 4; // Higher scale for better resolution
        const scaledCellSize = currentCellSize * renderScale;
        const scaledDotRadius = (currentDotSize / 2) * renderScale;

        canvas.width = cols * scaledCellSize;
        canvas.height = rows * scaledCellSize;
        const ctx = canvas.getContext('2d');

        combinedChart.forEach((row, rIdx) => {
            row.forEach((cellValue, cIdx) => {
                const x = cIdx * scaledCellSize;
                const y = rIdx * scaledCellSize;

                // Draw cell background
                if (cellValue === 'BB' || cellValue === 'BW') {
                    ctx.fillStyle = '#000'; // Black
                } else if (cellValue === 'WW' || cellValue === 'WB') {
                    ctx.fillStyle = '#fff'; // White
                } else {
                    ctx.fillStyle = '#e5e7eb'; // Gray fallback
                }
                ctx.fillRect(x, y, scaledCellSize, scaledCellSize);

                // Draw cell border
                ctx.strokeStyle = '#9ca3af'; // gray-400
                ctx.lineWidth = 1 * renderScale;
                ctx.strokeRect(x + ctx.lineWidth / 2, y + ctx.lineWidth / 2, scaledCellSize - ctx.lineWidth, scaledCellSize - ctx.lineWidth);

                // Draw solid circle dot if applicable (no stroke for solid look)
                if (cellValue === 'BW') { // Black background, White dot
                    ctx.fillStyle = '#fff'; // White dot color
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cellValue === 'WB') { // White background, Black dot
                    ctx.fillStyle = '#000'; // Black dot color
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });
        return canvas;
    }

    function downloadCombinedChart() {
        showMessage('Generating image...', 1000);
        const canvas = drawCombinedChartToCanvas();
        const image = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = image;
        link.download = 'double-knitting-combined-chart.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showMessage('Chart downloaded successfully!');
        console.log('Combined chart downloaded.');
    }

    function copyCombinedChart() {
        showMessage('Copying image to clipboard...', 1000);
        const canvas = drawCombinedChartToCanvas();
        canvas.toBlob(function(blob) {
            if (navigator.clipboard && navigator.clipboard.write) {
                const item = new ClipboardItem({ "image/png": blob });
                navigator.clipboard.write([item])
                    .then(() => {
                        showMessage('Chart copied to clipboard!');
                        console.log('Combined chart copied to clipboard (Clipboard API).');
                    })
                    .catch(err => {
                        console.warn('Failed to copy to clipboard using Clipboard API:', err);
                        showMessage('Failed to copy chart to clipboard.');
                    });
            } else {
                showMessage('Your browser does not support direct image copy to clipboard. Please download and copy manually.', 5000);
                console.warn('Clipboard API not available. Fallback to execCommand will likely fail for images.');
            }
        }, 'image/png');
    }

    function restartCharts() {
        console.log('Restarting charts...');
        rowsInput.value = 20;
        colsInput.value = 20;
        rows = 20;
        cols = 20;
        currentCellSize = 24;
        currentDotSize = 12;
        currentDotFontSize = 0.75;
        currentNumberFontSize = '0.7rem'; // Reset number font size

        initializeChartData();
        updateZoom(0); // Trigger a full re-render with default settings and empty charts
        showMessage('Charts have been reset!');
    }

    function inverseChartColors(chartType) {
        let targetChart;
        let targetElementId;

        if (chartType === 'front') {
            targetChart = frontChart;
            targetElementId = 'frontChartGrid';
        } else if (chartType === 'back') {
            targetChart = backChart;
            targetElementId = 'backChartGrid';
        }

        // Inverse the data
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                targetChart[r][c] = !targetChart[r][c];
                // Update the DOM cell's color
                const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${r}"][data-pattern-col="${c}"]`);
                if (cellDiv) {
                    cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
                    cellDiv.classList.add(targetChart[r][c] ? 'bg-black' : 'bg-white');
                }
            }
        }
        generateAndRenderCombinedChart(); // Regenerate and re-render combined chart
        showMessage(`${chartType} chart colors inverted!`);
    }

    // Event listeners for dimension inputs
    rowsInput.addEventListener('change', (e) => {
      rows = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    colsInput.addEventListener('change', (e) => {
      cols = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    // Event listeners for zoom buttons
    zoomInBtn.addEventListener('click', () => updateZoom(1));
    zoomOutBtn.addEventListener('click', () => updateZoom(-1));

    // Event listeners for download/copy/restart buttons
    downloadChartBtn.addEventListener('click', downloadCombinedChart);
    copyChartBtn.addEventListener('click', copyCombinedChart);
    restartBtn.addEventListener('click', restartCharts);

    // Event listeners for inverse buttons
    inverseFrontBtn.addEventListener('click', () => inverseChartColors('front'));
    inverseBackBtn.addEventListener('click', () => inverseChartColors('back'));

    // Initial setup on window load
    window.onload = () => {
        rows = Math.max(1, parseInt(rowsInput.value));
        cols = Math.max(1, parseInt(colsInput.value));
        initializeChartData();
        updateZoom(0); // This will trigger the first full render
    };
  </script>
</body>
</html>
