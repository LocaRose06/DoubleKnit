<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Double Knitting Pattern Generator</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- html2canvas CDN for converting the rendered HTML to image (for download/copy) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- jsPDF CDN for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Chosen Palette: Warm Neutrals with Subtle Indigo/Green/Red Accents -->
  <!-- Application Structure Plan: The application uses a three-column dashboard-like structure for its main content (Front Chart, Back Chart, Combined Chart). This allows users to simultaneously view their input patterns and the generated output, fostering direct comparison and immediate feedback. Controls for dimensions, zoom, and chart actions are positioned at the top for easy access. This structure was chosen for its intuitive visual flow, enabling users to easily explore the interactive data (pattern toggling) and synthesize the results (combined chart). -->
  <!-- Visualization & Content Choices:
    - Report Info -> Goal -> Viz/Presentation Method -> Interaction -> Justification -> Library/Method
    - Chart Data -> Inform/Design -> Interactive Grids (HTML Divs with dynamic classes) -> Cell click to toggle color -> Direct manipulation, visual feedback -> Vanilla JS
    - Combined Pattern Logic -> Inform/Synthesize -> Combined Chart (HTML Divs with dynamic classes and nested spans for dots) -> Auto-generated on input change -> Immediate visualization of complex logic -> Vanilla JS
    - Pattern Control -> Control -> Numeric Inputs (HTML Input) -> Input change for dimension update -> Precise control over grid size -> Vanilla JS
    - Zoom Control -> Explore/Context -> Buttons (HTML Button) -> Click to adjust cell size -> Adaptability for detail/overview -> Vanilla JS, CSS Variables
    - Image Download/Copy -> Output -> Buttons (HTML Button) -> Click to save/copy image -> User utility, sharing -> Canvas API (for dots), html2canvas (for overall capture)
    - Restart -> Control -> Button (HTML Button) -> Click to reset patterns -> User convenience -> Vanilla JS
    - Chart Labeling -> Inform -> Column/Row Numbers (HTML Divs/Spans directly in grid) -> Dynamically rendered, respond to zoom -> Improved clarity for knitting patterns (right-to-left for cols at bottom, bottom-to-top for rows) -> Vanilla JS
    - Written Instructions -> Inform/Action -> Text area (HTML Div) & Buttons (HTML Button) -> Click to generate/download text or combined document -> Provides alternative pattern format -> Vanilla JS
    - Information Architecture is designed to be highly interactive and task-oriented, allowing direct manipulation of input and immediate viewing of output.
  -->
  <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    /* Hide scrollbar for grid containers */
    .overflow-y-auto::-webkit-scrollbar {
      display: none;
    }
    .overflow-y-auto {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    /* Custom styles for grid cells - initial size will be set by JS */
    :root {
        --cell-size: 24px; /* Default cell size */
        --dot-size: 12px; /* Default dot size, half of cell-size */
        --dot-font-size: 0.75rem; /* text-xs for dots */
        --number-font-size: 0.7rem; /* Font size for row/col numbers */
    }
    .grid-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid #9ca3af; /* Equivalent to border border-gray-400 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      display: flex; /* Use flex to center content */
      align-items: center; /* Center vertically */
      justify-content: center; /* Center horizontally */
      position: relative; /* For absolute positioning of dot-container */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      overflow: hidden; /* Hide anything outside the cell */
    }
    .grid-cell-editable:hover {
      opacity: 0.75;
      cursor: pointer;
    }
    .bg-black { background-color: #000; }
    .bg-white { background-color: #fff; }
    .bg-gray-200 { background-color: #e5e7eb; } /* Fallback/initial color */
    .text-white { color: #fff; }
    .text-black { color: #000; }
    .border-gray-500 { border-color: #6b7280; }

    /* Styles for the message box */
    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #333;
        color: #fff;
        padding: 15px 30px;
        border-radius: 8px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        font-weight: 600;
        text-align: center;
    }
    .message-box.show {
        opacity: 1;
    }

    /* Improved centering for dots using absolute positioning */
    .grid-cell .dot-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Centering trick */
        width: var(--dot-size);
        height: var(--dot-size);
        line-height: var(--dot-size); /* Ensure text is vertically centered within its own box */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 9999px; /* rounded-full */
        border: 1px solid #6b7280; /* border-gray-500 */
        font-size: var(--dot-font-size);
        box-sizing: border-box; /* Include border in size */
    }

    /* Styles for number headers */
    .number-header {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--number-font-size); /* Now scales with zoom */
        color: #4b5563; /* gray-700 */
        font-weight: 600;
        box-sizing: border-box;
    }
    /* Specific styling for the top-left blank corner of the grid */
    .corner-header {
      width: var(--cell-size);
      height: var(--cell-size);
    }
    .chart-grid-container {
      display: grid;
      gap: 1px; /* Equivalent to gap-px */
      background-color: #d1d5db; /* Equivalent to bg-gray-300 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      max-height: 400px;
      overflow: auto; /* Use auto for scrolling content, not hidden */
      overflow-y: auto; /* Scroll for height */
      overflow-x: auto; /* Scroll for width if content exceeds */
    }
    /* Hide scrollbar for the specific grid containers */
    .chart-grid-container::-webkit-scrollbar {
        display: none;
    }
    .chart-grid-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }

    /* Styles for Written Instructions Output */
    #writtenInstructionsOutput {
        white-space: pre-wrap; /* Preserves whitespace and wraps text */
        font-family: 'Courier New', Courier, monospace; /* Monospace font for pattern text */
        background-color: #f8fafc; /* bg-gray-50 */
        border: 1px solid #e2e8f0; /* border-gray-200 */
        border-radius: 0.5rem; /* rounded-lg */
        padding: 1.5rem; /* p-6 */
        margin-top: 2.5rem; /* mt-10 */
        max-width: 42rem; /* max-w-xl (approx) */
        margin-left: auto;
        margin-right: auto;
        color: #334155; /* text-slate-700 */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.5;
        overflow-x: auto; /* Allow horizontal scroll for long lines */
        min-height: 50px; /* Ensure it's visible even when empty */
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-100 to-indigo-200 p-8 font-inter text-gray-800">
  <h1 class="text-4xl font-bold text-center mb-10 text-indigo-800 drop-shadow-lg">
    Double Knitting Pattern Generator
  </h1>

  <!-- Global Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mb-8 space-y-4 md:space-y-0 md:space-x-4">
    <!-- Grid Dimension Controls -->
    <div class="flex items-center space-x-4">
      <label for="rows" class="font-medium text-lg">Rows:</label>
      <input
        type="number"
        id="rows"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
      <label for="cols" class="font-medium text-lg">Columns:</label>
      <input
        type="number"
        id="cols"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
    </div>

    <!-- Zoom Controls -->
    <div class="flex items-center space-x-4">
      <span class="font-medium text-lg">Zoom:</span>
      <button id="zoomOutBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom Out
      </button>
      <button id="zoomInBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom In
      </button>
    </div>
  </div>

  <!-- Chart Display Area -->
  <div class="flex flex-wrap justify-center items-start">
    <!-- Front Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Front Chart (Click to toggle color)</h3>
      <div id="frontChartGrid" class="chart-grid-container"></div>
      <button id="inverseFrontBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Front Colors
      </button>
    </div>

    <!-- Back Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Back Chart (Click to toggle color)</h3>
      <div id="backChartGrid" class="chart-grid-container"></div>
      <button id="inverseBackBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Back Colors
      </button>
    </div>

    <!-- Combined Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Combined Chart (Read-Only)</h3>
      <div id="combinedChartGrid" class="chart-grid-container"></div>
    </div>
  </div>

  <!-- Optional Title Input -->
  <div class="flex justify-center items-center mb-8 space-x-4">
    <label for="patternTitleInput" class="font-medium text-lg">Pattern Title (Optional):</label>
    <input
      type="text"
      id="patternTitleInput"
      placeholder="e.g., My Custom Pattern"
      class="w-64 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
    />
  </div>

  <!-- Action Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mt-8 space-y-4 md:space-y-0 md:space-x-4">
    <button id="generateInstructionsBtn" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Generate Written Instructions
    </button>
    <button id="downloadInstructionsBtn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Written Instructions (PDF)
    </button>
    <button id="downloadCombinedDocumentBtn" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Full Pattern (PDF)
    </button>
    <button id="downloadChartBtn" class="px-6 py-3 bg-orange-500 text-white font-semibold rounded-md shadow-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Combined Chart (PDF)
    </button>
    <button id="restartBtn" class="px-6 py-3 bg-red-500 text-white font-semibold rounded-md shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Restart Charts
    </button>
  </div>

  <!-- Written Instructions Output Area -->
  <div id="writtenInstructionsOutput" class="hidden">
    <h3 class="text-xl font-semibold mb-4 text-gray-800">Generated Written Instructions:</h3>
    <pre id="instructionsText" class="text-sm text-gray-700"></pre>
    <p class="mt-4 text-gray-600">
      <strong>Instructions Legend:</strong><br>
      - "KB/PW": Knit Black on Front, Purl White on Back.<br>
      - "KW/PB": Knit White on Front, Purl Black on Back.<br>
      - "KBB": Knit Black on Both Front and Back.<br>
      - "KWW": Knit White on Both Front and Back.
    </p>
  </div>

  <div class="text-center mt-10 p-4 bg-white rounded-lg shadow-lg max-w-2xl mx-auto">
    <h2 class="text-2xl font-semibold mb-4 text-indigo-700">Understanding the Combined Chart:</h2>
    <p class="text-gray-700 mb-2">
      This version of the combined chart uses simple color codes:
    </p>
    <ul class="list-disc list-inside text-left text-gray-600 mx-auto w-fit">
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Black cell with White dot (⚪):</span> Front is Black, Back is White. (e.g., Knit with Black yarn, Purl with White yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">White cell with Black dot (⚫):</span> Front is White, Back is Black. (e.g., Knit with White yarn, Purl with Black yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure Black cell:</span> Both Front and Back are Black. (e.g., Knit with Black, Purl with Black)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure White cell:</span> Both Front and Back are White. (e.g., Knit with White, Purl with White)</li>
    </ul>
    <p class="text-gray-700 mt-4">
      The dot representation on the combined chart clarifies the individual knit and purl stitches when the front and back patterns differ.
    </p>
  </div>

  <!-- Message box for copy/download feedback -->
  <div id="messageBox" class="message-box hidden"></div>

  <script>
    let rows = 20;
    let cols = 20;
    let frontChart = [];
    let backChart = [];
    let combinedChart = [];
    let currentCellSize = 24;
    let currentDotSize = 12;
    let currentDotFontSize = 0.75;
    let currentNumberFontSize = '0.7rem';

    const MIN_CELL_SIZE = 8;
    const MAX_CELL_SIZE = 60;
    const ZOOM_STEP = 4;

    const frontChartGridElement = document.getElementById('frontChartGrid');
    const backChartGridElement = document.getElementById('backChartGrid');
    const combinedChartGridElement = document.getElementById('combinedChartGrid');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const downloadChartBtn = document.getElementById('downloadChartBtn');
    const restartBtn = document.getElementById('restartBtn');
    const inverseFrontBtn = document.getElementById('inverseFrontBtn');
    const inverseBackBtn = document.getElementById('inverseBackBtn');
    const generateInstructionsBtn = document.getElementById('generateInstructionsBtn');
    const downloadInstructionsBtn = document.getElementById('downloadInstructionsBtn');
    const downloadCombinedDocumentBtn = document.getElementById('downloadCombinedDocumentBtn');
    const writtenInstructionsOutput = document.getElementById('writtenInstructionsOutput');
    const instructionsText = document.getElementById('instructionsText');
    const patternTitleInput = document.getElementById('patternTitleInput');
    const messageBox = document.getElementById('messageBox');

    const { jsPDF } = window.jspdf;

    function showMessage(message, duration = 3000) {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden');
        messageBox.classList.add('show');
        setTimeout(() => {
            messageBox.classList.remove('show');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 500);
        }, duration);
    }

    function createEmptyChart(r, c, startBlack = false) {
      return Array(r).fill(null).map(() => Array(c).fill(startBlack));
    }

    function initializeChartData() {
        frontChart = createEmptyChart(rows, cols, false);
        backChart = createEmptyChart(rows, cols, true);
        console.log('Chart data initialized.');
    }

    function renderChart(chartData, containerElementId, enableEdit, chartType) {
        const containerElement = document.getElementById(containerElementId);
        containerElement.innerHTML = '';

        containerElement.style.gridTemplateColumns = `var(--cell-size) repeat(${cols}, var(--cell-size))`;
        containerElement.style.gridTemplateRows = `repeat(${rows}, var(--cell-size)) var(--cell-size)`;

        for (let rDisplay = rows; rDisplay >= 1; rDisplay--) {
            const patternRIdx = rows - rDisplay;

            const rowHeader = document.createElement('div');
            rowHeader.classList.add('number-header');
            rowHeader.textContent = rDisplay;
            containerElement.appendChild(rowHeader);

            for (let cDisplay = 1; cDisplay <= cols; cDisplay++) {
                const patternCIdx = cDisplay - 1;

                const cellDiv = document.createElement('div');
                cellDiv.classList.add('grid-cell');
                cellDiv.dataset.patternRow = patternRIdx;
                cellDiv.dataset.patternCol = patternCIdx;

                if (enableEdit) {
                    cellDiv.classList.add('grid-cell-editable');
                    cellDiv.addEventListener('click', () => toggleCell(chartType, patternRIdx, patternCIdx));
                }

                if (chartType === 'front') {
                    cellDiv.classList.add(frontChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                } else if (chartType === 'back') {
                    cellDiv.classList.add(backChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                }
                containerElement.appendChild(cellDiv);
            }
        }

        const bottomLeftCornerDiv = document.createElement('div');
        bottomLeftCornerDiv.classList.add('corner-header');
        containerElement.appendChild(bottomLeftCornerDiv);

        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) {
            const colHeader = document.createElement('div');
            colHeader.classList.add('number-header');
            colHeader.textContent = cDisplay;
            containerElement.appendChild(colHeader);
        }
    }

    function toggleCell(chartType, patternRIdx, patternCIdx) {
      console.log(`Toggling cell [${patternRIdx}, ${patternCIdx}] in ${chartType} chart.`);
      let targetChart;
      let targetElementId;

      if (chartType === 'front') {
        targetChart = frontChart;
        targetElementId = 'frontChartGrid';
      } else if (chartType === 'back') {
        targetChart = backChart;
        targetElementId = 'backChartGrid';
      }

      targetChart[patternRIdx][patternCIdx] = !targetChart[patternRIdx][patternCIdx];
      const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${patternRIdx}"][data-pattern-col="${patternCIdx}"]`);
      if (cellDiv) {
          cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
          cellDiv.classList.add(targetChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
      }
      generateAndRenderCombinedChart();
    }

    function generateAndRenderCombinedChart() {
      console.log('Generating and rendering combined chart...');
      combinedChart = frontChart.map((frontRow, rIdx) =>
        frontRow.map((frontCell, cIdx) => {
          const backCell = backChart[rIdx][cIdx];

          if (frontCell && !backCell) {
            return 'BW';
          } else if (!frontCell && backCell) {
            return 'WB';
          } else if (frontCell && backCell) {
            return 'BB';
          } else {
            return 'WW';
          }
        })
      );
      console.log('New Combined Chart Data (for DOM render):', combinedChart);

      combinedChart.forEach((row, rIdx) => {
        row.forEach((cellValue, cIdx) => {
          const cellDiv = combinedChartGridElement.querySelector(`[data-pattern-row="${rIdx}"][data-pattern-col="${cIdx}"]`);
          if (cellDiv) {
            let backgroundColorClass = 'bg-gray-200';
            let dotContentHTML = '';

            if (cellValue === 'BB' || cellValue === 'BW') {
              backgroundColorClass = 'bg-black';
            } else if (cellValue === 'WW' || cellValue === 'WB') {
              backgroundColorClass = 'bg-white';
            }

            cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
            cellDiv.classList.add(backgroundColorClass);

            if (cellValue === 'BW') {
              dotContentHTML = '<span class="dot-container text-white">⚪</span>';
            } else if (cellValue === 'WB') {
              dotContentHTML = '<span class="dot-container text-black">⚫</span>';
            }
            cellDiv.innerHTML = dotContentHTML;
          }
        });
      });
      console.log('Combined Chart rendered to DOM.');
    }

    function updateZoom(factor) {
        let newSize = currentCellSize + (factor * ZOOM_STEP);
        newSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, newSize));

        if (newSize !== currentCellSize) {
            currentCellSize = newSize;
            currentDotSize = Math.max(8, Math.round(currentCellSize / 2));
            currentDotFontSize = Math.max(0.5, currentCellSize / 32);
            currentNumberFontSize = `${Math.max(0.6, currentCellSize / 35)}rem`;

            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
            document.documentElement.style.setProperty('--dot-size', `${currentDotSize}px`);
            document.documentElement.style.setProperty('--dot-font-size', `${currentDotFontSize}rem`);
            document.documentElement.style.setProperty('--number-font-size', currentNumberFontSize);
        }

        renderChart(frontChart, 'frontChartGrid', true, 'front');
        renderChart(backChart, 'backChartGrid', true, 'back');
        renderChart(combinedChart, 'combinedChartGrid', false, 'combined');
        generateAndRenderCombinedChart();
        console.log(`Zoom updated to cell size: ${currentCellSize}px, dot size: ${currentDotSize}px, font size: ${currentDotFontSize}rem, number font size: ${currentNumberFontSize}.`);
    }

    function drawCombinedChartToCanvas() {
        const canvas = document.createElement('canvas');
        const renderScale = 4;
        const scaledCellSize = currentCellSize * renderScale;
        const scaledDotRadius = (currentDotSize / 2) * renderScale;
        const scaledNumberFontSizePx = parseFloat(currentNumberFontSize) * 16 * renderScale;

        canvas.width = (cols + 1) * scaledCellSize;
        canvas.height = (rows + 1) * scaledCellSize;
        const ctx = canvas.getContext('2d');

        ctx.font = `${scaledNumberFontSizePx}px Inter`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#4b5563';

        // Draw Blank Top-Left Corner
        ctx.fillStyle = '#f3f4f6';
        ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1 * renderScale;
        ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);

        // Draw Row Numbers (left-most column)
        for (let rIdx = 0; rIdx < rows; rIdx++) {
            const rDisplay = rows - rIdx;
            const canvasY = rIdx * scaledCellSize;

            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(0, canvasY, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(0, canvasY, scaledCellSize, scaledCellSize);

            ctx.fillStyle = '#4b5563';
            ctx.fillText(rDisplay.toString(), scaledCellSize / 2, canvasY + scaledCellSize / 2);
        }

        // Draw Pattern Cells
        combinedChart.forEach((row, rIdx) => {
            row.forEach((cellValue, cIdx) => {
                const x = (cIdx + 1) * scaledCellSize;
                const y = rIdx * scaledCellSize;

                if (cellValue === 'BB' || cellValue === 'BW') {
                    ctx.fillStyle = '#000';
                } else if (cellValue === 'WW' || cellValue === 'WB') {
                    ctx.fillStyle = '#fff';
                } else {
                    ctx.fillStyle = '#e5e7eb';
                }
                ctx.fillRect(x, y, scaledCellSize, scaledCellSize);

                ctx.strokeStyle = '#9ca3af';
                ctx.lineWidth = 1 * renderScale;
                ctx.strokeRect(x + ctx.lineWidth / 2, y + ctx.lineWidth / 2, scaledCellSize - ctx.lineWidth, scaledCellSize - ctx.lineWidth);

                if (cellValue === 'BW') {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cellValue === 'WB') {
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });

        // Draw Column Numbers (bottom-most row)
        const colNumbersY = rows * scaledCellSize;
        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) {
            const canvasX = (cols - cDisplay + 1) * scaledCellSize;

            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize);

            ctx.fillStyle = '#4b5563';
            ctx.fillText(cDisplay.toString(), canvasX + scaledCellSize / 2, colNumbersY + scaledCellSize / 2);
        }

        return canvas;
    }

    async function downloadCombinedChartPDF() {
        showMessage('Generating chart PDF...', 1000);
        const canvas = drawCombinedChartToCanvas();
        const imgData = canvas.toDataURL('image/png');
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF('landscape', 'pt', 'a4');
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = doc.internal.pageSize.getHeight();
        let currentY = 20;

        if (title) {
            doc.setFontSize(18);
            doc.text(title, pdfWidth / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        doc.setFontSize(14);
        doc.text("Double Knitting Combined Chart", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;

        const imgProps= doc.getImageProperties(imgData);
        const imgRatio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth * 0.9;
        let imgHeight = imgWidth / imgRatio;

        if (imgHeight > (pdfHeight - currentY - 20)) {
            imgHeight = pdfHeight - currentY - 20;
            imgWidth = imgHeight * imgRatio;
        }

        const xOffset = (pdfWidth - imgWidth) / 2;

        doc.addImage(imgData, 'PNG', xOffset, currentY, imgWidth, imgHeight);
        doc.save('double-knitting-combined-chart.pdf');
        showMessage('Chart PDF downloaded successfully!');
        console.log('Combined chart PDF downloaded.');
    }

    function generateWrittenInstructions() {
        let instructions = "Double Knitting Pattern Instructions:\n\n";
        instructions += `Chart Size: ${rows} Rows x ${cols} Columns\n\n`;

        for (let rIdx = 0; rIdx < rows; rIdx++) {
            const rDisplay = rIdx + 1;
            instructions += `Row ${rDisplay}: `;

            let rowInstructions = [];
            for (let cIdx = 0; cIdx < cols; cIdx++) {
                const cellValue = combinedChart[rIdx][cIdx];
                switch (cellValue) {
                    case 'BW':
                        rowInstructions.push("KB/PW");
                        break;
                    case 'WB':
                        rowInstructions.push("KW/PB");
                        break;
                    case 'BB':
                        rowInstructions.push("KBB");
                        break;
                    case 'WW':
                        rowInstructions.push("KWW");
                        break;
                }
            }
            instructions += rowInstructions.join(", ") + ".\n";
        }

        instructionsText.textContent = instructions;
        writtenInstructionsOutput.classList.remove('hidden');
        showMessage('Instructions generated!');
        return instructions;
    }

    async function downloadWrittenInstructionsPDF() {
        showMessage('Generating instructions PDF...', 1000);
        const instructions = generateWrittenInstructions();
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF();
        let currentY = 20;

        if (title) {
            doc.setFontSize(18);
            doc.text(title, doc.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        doc.setFontSize(14);
        doc.text("Written Double Knitting Instructions", doc.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
        currentY += 20;

        doc.setFontSize(10);
        const textLines = doc.splitTextToSize(instructions, doc.internal.pageSize.getWidth() - 20);
        doc.text(textLines, 10, currentY);

        currentY += (textLines.length * 10) + 10;

        doc.setFontSize(10);
        doc.text("Instructions Legend:", 10, currentY);
        currentY += 15;
        doc.text("- KB/PW: Knit Black on Front, Purl White on Back.", 15, currentY);
        currentY += 10;
        doc.text("- KW/PB: Knit White on Front, Purl Black on Back.", 15, currentY);
        currentY += 10;
        doc.text("- KBB: Knit Black on Both Front and Back.", 15, currentY);
        currentY += 10;
        doc.text("- KWW: Knit White on Both Front and Back.", 15, currentY);


        doc.save('double-knitting-instructions.pdf');
        showMessage('Instructions PDF downloaded successfully!');
        console.log('Instructions PDF downloaded.');
    }

    async function downloadCombinedPatternDocumentPDF() {
        showMessage('Generating full pattern PDF...', 1000);

        const canvas = drawCombinedChartToCanvas();
        const imageUrl = canvas.toDataURL('image/png');

        const instructions = generateWrittenInstructions();
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF('portrait', 'pt', 'a4');
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = doc.internal.pageSize.getHeight();
        const margin = 36; // 0.5 inch margin, approx 36pt
        let currentY = margin;

        // Add Title
        if (title) {
            doc.setFontSize(18);
            doc.text(title, pdfWidth / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        // Add Main Heading for the document
        doc.setFontSize(14);
        doc.text("Double Knitting Pattern: Visual Chart & Written Instructions", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 40; // More space after main heading

        // Add Chart Section Heading and Description
        doc.setFontSize(16);
        doc.text("Combined Pattern Chart", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;
        doc.setFontSize(10);
        doc.text("This chart includes row numbers (left, bottom-to-top) and column numbers (bottom, right-to-left).", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 15;

        // Add Chart Image
        const imgProps = doc.getImageProperties(imageUrl);
        const imgRatio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth - (2 * margin); // Use full available width
        let imgHeight = imgWidth / imgRatio;

        // Scale down if image is too tall for the remaining page
        const maxImgHeight = pdfHeight - currentY - margin - (doc.getFontSize() * 5); // Leave space for instructions text
        if (imgHeight > maxImgHeight) {
            imgHeight = maxImgHeight;
            imgWidth = imgHeight * imgRatio;
        }

        const imgX = (pdfWidth - imgWidth) / 2;
        doc.addImage(imageUrl, 'PNG', imgX, currentY, imgWidth, imgHeight);
        currentY += imgHeight + 30; // Move Y below the image + some padding

        // Add Written Instructions Section Heading
        // Check if new page is needed before adding instructions
        if (currentY + (doc.getFontSize() * 2) > pdfHeight - margin) {
            doc.addPage();
            currentY = margin;
        }
        doc.setFontSize(16);
        doc.text("Written Instructions", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;

        // Add Instructions Text
        doc.setFontSize(10);
        const textLines = doc.splitTextToSize(instructions, pdfWidth - (2 * margin));
        
        for (let i = 0; i < textLines.length; i++) {
            if (currentY + doc.getLineHeight() > pdfHeight - margin) { // Check if line will overflow
                doc.addPage();
                currentY = margin;
            }
            doc.text(textLines[i], margin, currentY);
            currentY += doc.getLineHeight();
        }
        currentY += 10; // Extra space after instructions

        // Add Instructions Legend
        // Check if new page is needed before adding legend
        if (currentY + (doc.getFontSize() * 5) > pdfHeight - margin) { // Approx height for legend
            doc.addPage();
            currentY = margin;
        }
        doc.setFontSize(10);
        doc.text("Instructions Legend:", margin, currentY);
        currentY += 15;
        doc.text("- KB/PW: Knit Black on Front, Purl White on Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KW/PB: Knit White on Front, Purl Black on Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KBB: Knit Black on Both Front and Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KWW: Knit White on Both Front and Back.", margin + 5, currentY);
        
        doc.save('double-knitting-full-pattern.pdf');
        showMessage('Full pattern PDF downloaded successfully!');
        console.log('Full pattern PDF downloaded.');
    }

    function restartCharts() {
        console.log('Restarting charts...');
        rowsInput.value = 20;
        colsInput.value = 20;
        rows = 20;
        cols = 20;
        currentCellSize = 24;
        currentDotSize = 12;
        currentDotFontSize = 0.75;
        currentNumberFontSize = '0.7rem';
        patternTitleInput.value = '';

        initializeChartData();
        updateZoom(0);
        writtenInstructionsOutput.classList.add('hidden');
        showMessage('Charts have been reset!');
    }

    function inverseChartColors(chartType) {
        let targetChart;
        let targetElementId;

        if (chartType === 'front') {
            targetChart = frontChart;
            targetElementId = 'frontChartGrid';
        } else if (chartType === 'back') {
            targetChart = backChart;
            targetElementId = 'backChartGrid';
        }

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                targetChart[r][c] = !targetChart[r][c];
                const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${r}"][data-pattern-col="${c}"]`);
                if (cellDiv) {
                    cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
                    cellDiv.classList.add(targetChart[r][c] ? 'bg-black' : 'bg-white');
                }
            }
        }
        generateAndRenderCombinedChart();
        showMessage(`${chartType} chart colors inverted!`);
    }

    // Event listeners
    rowsInput.addEventListener('change', (e) => {
      rows = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    colsInput.addEventListener('change', (e) => {
      cols = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    zoomInBtn.addEventListener('click', () => updateZoom(1));
    zoomOutBtn.addEventListener('click', () => updateZoom(-1));
    downloadChartBtn.addEventListener('click', downloadCombinedChartPDF);
    restartBtn.addEventListener('click', restartCharts);
    inverseFrontBtn.addEventListener('click', () => inverseChartColors('front'));
    inverseBackBtn.addEventListener('click', () => inverseChartColors('back'));
    generateInstructionsBtn.addEventListener('click', generateWrittenInstructions);
    downloadInstructionsBtn.addEventListener('click', downloadWrittenInstructionsPDF);
    downloadCombinedDocumentBtn.addEventListener('click', downloadCombinedPatternDocumentPDF);


    // Initial setup on window load
    window.onload = () => {
        rows = Math.max(1, parseInt(rowsInput.value));
        cols = Math.max(1, parseInt(colsInput.value));
        initializeChartData();
        updateZoom(0);
    };
  </script>
</body>
</html>
