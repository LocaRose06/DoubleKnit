<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Double Knitting Pattern Generator</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- html2canvas CDN for converting the rendered HTML to image (for download/copy) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Chosen Palette: Warm Neutrals with Subtle Indigo/Green/Red Accents -->
  <!-- Application Structure Plan: The application uses a three-column dashboard-like structure for its main content (Front Chart, Back Chart, Combined Chart). This allows users to simultaneously view their input patterns and the generated output, fostering direct comparison and immediate feedback. Controls for dimensions, zoom, and chart actions are positioned at the top for easy access. This structure was chosen for its intuitive visual flow, enabling users to easily explore the interactive data (pattern toggling) and synthesize the results (combined chart). -->
  <!-- Visualization & Content Choices:
    - Report Info -> Goal -> Viz/Presentation Method -> Interaction -> Justification -> Library/Method
    - Chart Data -> Inform/Design -> Interactive Grids (HTML Divs with dynamic classes) -> Cell click to toggle color -> Direct manipulation, visual feedback -> Vanilla JS
    - Combined Pattern Logic -> Inform/Synthesize -> Combined Chart (HTML Divs with dynamic classes and nested spans for dots) -> Auto-generated on input change -> Immediate visualization of complex logic -> Vanilla JS
    - Pattern Control -> Control -> Numeric Inputs (HTML Input) -> Input change for dimension update -> Precise control over grid size -> Vanilla JS
    - Zoom Control -> Explore/Context -> Buttons (HTML Button) -> Click to adjust cell size -> Adaptability for detail/overview -> Vanilla JS, CSS Variables
    - Image Download/Copy -> Output -> Buttons (HTML Button) -> Click to save/copy image -> User utility, sharing -> Canvas API (for dots), html2canvas (for overall capture)
    - Restart -> Control -> Button (HTML Button) -> Click to reset patterns -> User convenience -> Vanilla JS
    - Chart Labeling -> Inform -> Column/Row Numbers (HTML Divs/Spans directly in grid) -> Dynamically rendered, respond to zoom -> Improved clarity for knitting patterns (right-to-left for cols at bottom, bottom-to-top for rows) -> Vanilla JS
    - Information Architecture is designed to be highly interactive and task-oriented, allowing direct manipulation of input and immediate viewing of output.
  -->
  <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    /* Hide scrollbar for grid containers */
    .overflow-y-auto::-webkit-scrollbar {
      display: none;
    }
    .overflow-y-auto {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    /* Custom styles for grid cells - initial size will be set by JS */
    :root {
        --cell-size: 24px; /* Default cell size */
        --dot-size: 12px; /* Default dot size, half of cell-size */
        --dot-font-size: 0.75rem; /* text-xs for dots */
        --number-font-size: 0.7rem; /* Font size for row/col numbers */
    }
    .grid-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid #9ca3af; /* Equivalent to border border-gray-400 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      display: flex; /* Use flex to center content */
      align-items: center; /* Center vertically */
      justify-content: center; /* Center horizontally */
      position: relative; /* For absolute positioning of dot-container */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      overflow: hidden; /* Hide anything outside the cell */
    }
    .grid-cell-editable:hover {
      opacity: 0.75;
      cursor: pointer;
    }
    .bg-black { background-color: #000; }
    .bg-white { background-color: #fff; }
    .bg-gray-200 { background-color: #e5e7eb; } /* Fallback/initial color */
    .text-white { color: #fff; }
    .text-black { color: #000; }
    .border-gray-500 { border-color: #6b7280; }

    /* Styles for the message box */
    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #333;
        color: #fff;
        padding: 15px 30px;
        border-radius: 8px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        font-weight: 600;
        text-align: center;
    }
    .message-box.show {
        opacity: 1;
    }

    /* Improved centering for dots using absolute positioning */
    .grid-cell .dot-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Centering trick */
        width: var(--dot-size);
        height: var(--dot-size);
        line-height: var(--dot-size); /* Ensure text is vertically centered within its own box */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 9999px; /* rounded-full */
        border: 1px solid #6b7280; /* border-gray-500 */
        font-size: var(--dot-font-size);
        box-sizing: border-box; /* Include border in size */
    }

    /* Styles for number headers */
    .number-header {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--number-font-size); /* Now scales with zoom */
        color: #4b5563; /* gray-700 */
        font-weight: 600;
        box-sizing: border-box;
    }
    /* Specific styling for the top-left blank corner of the grid */
    .corner-header {
      width: var(--cell-size);
      height: var(--cell-size);
    }
    .chart-grid-container {
      display: grid;
      gap: 1px; /* Equivalent to gap-px */
      background-color: #d1d5db; /* Equivalent to bg-gray-300 */
      border-radius: 2px; /* Equivalent to rounded-sm */
      max-height: 400px;
      overflow: auto; /* Use auto for scrolling content, not hidden */
      overflow-y: auto; /* Scroll for height */
      overflow-x: auto; /* Scroll for width if content exceeds */
    }
    /* Hide scrollbar for the specific grid containers */
    .chart-grid-container::-webkit-scrollbar {
        display: none;
    }
    .chart-grid-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-100 to-indigo-200 p-8 font-inter text-gray-800">
  <h1 class="text-4xl font-bold text-center mb-10 text-indigo-800 drop-shadow-lg">
    Double Knitting Pattern Generator
  </h1>

  <!-- Global Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mb-8 space-y-4 md:space-y-0 md:space-x-4">
    <!-- Grid Dimension Controls -->
    <div class="flex items-center space-x-4">
      <label for="rows" class="font-medium text-lg">Rows:</label>
      <input
        type="number"
        id="rows"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
      <label for="cols" class="font-medium text-lg">Columns:</label>
      <input
        type="number"
        id="cols"
        value="20"
        min="1"
        class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
      />
    </div>

    <!-- Zoom Controls -->
    <div class="flex items-center space-x-4">
      <span class="font-medium text-lg">Zoom:</span>
      <button id="zoomOutBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom Out
      </button>
      <button id="zoomInBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-md shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
        Zoom In
      </button>
    </div>
  </div>

  <!-- Chart Display Area -->
  <div class="flex flex-wrap justify-center items-start">
    <!-- Front Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Front Chart (Click to toggle color)</h3>
      <div id="frontChartGrid" class="chart-grid-container"></div>
      <button id="inverseFrontBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Front Colors
      </button>
    </div>

    <!-- Back Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Back Chart (Click to toggle color)</h3>
      <div id="backChartGrid" class="chart-grid-container"></div>
      <button id="inverseBackBtn" class="mt-4 px-4 py-2 bg-purple-500 text-white rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
        Inverse Back Colors
      </button>
    </div>

    <!-- Combined Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-gray-800">Combined Chart (Read-Only)</h3>
      <div id="combinedChartGrid" class="chart-grid-container"></div>
    </div>
  </div>

  <!-- Download/Copy/Restart Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mt-8 space-y-4 md:space-y-0 md:space-x-4">
    <button id="downloadChartBtn" class="px-6 py-3 bg-green-500 text-white font-semibold rounded-md shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Combined Chart (PNG)
    </button>
    <button id="copyChartBtn" class="px-6 py-3 bg-blue-500 text-white font-semibold rounded-md shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Copy Combined Chart (Image)
    </button>
    <button id="restartBtn" class="px-6 py-3 bg-red-500 text-white font-semibold rounded-md shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-150 ease-in-out">
      Restart Charts
    </button>
  </div>

  <div class="text-center mt-10 p-4 bg-white rounded-lg shadow-lg max-w-2xl mx-auto">
    <h2 class="text-2xl font-semibold mb-4 text-indigo-700">Understanding the Combined Chart:</h2>
    <p class="text-gray-700 mb-2">
      This version of the combined chart uses simple color codes:
    </p>
    <ul class="list-disc list-inside text-left text-gray-600 mx-auto w-fit">
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Black cell with White dot (⚪):</span> Front is Black, Back is White. (e.g., Knit with Black yarn, Purl with White yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">White cell with Black dot (⚫):</span> Front is White, Back is Black. (e.g., Knit with White yarn, Purl with Black yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-black border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure Black cell:</span> Both Front and Back are Black. (e.g., Knit with Black, Purl with Black)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-gray-400 rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure White cell:</span> Both Front and Back are White. (e.g., Knit with White, Purl with White)</li>
    </ul>
    <p class="text-gray-700 mt-4">
      The dot representation on the combined chart clarifies the individual knit and purl stitches when the front and back patterns differ.
    </p>
  </div>

  <!-- Message box for copy/download feedback -->
  <div id="messageBox" class="message-box hidden"></div>

  <script>
    let rows = 20;
    let cols = 20;
    let frontChart = [];
    let backChart = [];
    let combinedChart = [];
    let currentCellSize = 24; // Initial cell size in pixels
    let currentDotSize = 12; // Initial dot size, half of cell-size
    let currentDotFontSize = 0.75; // Initial font size in rem for dots
    let currentNumberFontSize = '0.7rem'; // Initial font size for numbers

    const MIN_CELL_SIZE = 8;
    const MAX_CELL_SIZE = 60;
    const ZOOM_STEP = 4; // Pixel step for cell size

    const frontChartGridElement = document.getElementById('frontChartGrid');
    const backChartGridElement = document.getElementById('backChartGrid');
    const combinedChartGridElement = document.getElementById('combinedChartGrid');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const downloadChartBtn = document.getElementById('downloadChartBtn');
    const copyChartBtn = document.getElementById('copyChartBtn');
    const restartBtn = document.getElementById('restartBtn');
    const inverseFrontBtn = document.getElementById('inverseFrontBtn');
    const inverseBackBtn = document.getElementById('inverseBackBtn');
    const messageBox = document.getElementById('messageBox');

    function showMessage(message, duration = 3000) {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden');
        messageBox.classList.add('show');
        setTimeout(() => {
            messageBox.classList.remove('show');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 500);
        }, duration);
    }

    function createEmptyChart(r, c, startBlack = false) {
      return Array(r).fill(null).map(() => Array(c).fill(startBlack));
    }

    function initializeChartData() {
        frontChart = createEmptyChart(rows, cols, false); // Front starts white
        backChart = createEmptyChart(rows, cols, true); // Back starts black
        console.log('Chart data initialized.');
    }

    // Function to render an entire chart grid, including headers
    function renderChart(chartData, containerElementId, enableEdit, chartType) {
        const containerElement = document.getElementById(containerElementId);
        containerElement.innerHTML = ''; // Clear existing cells

        // Set grid template columns: 1 for row numbers, then 'cols' for pattern cells
        containerElement.style.gridTemplateColumns = `var(--cell-size) repeat(${cols}, var(--cell-size))`;
        // Set grid template rows: 'rows' for pattern cells, then 1 for column numbers (at the bottom)
        containerElement.style.gridTemplateRows = `repeat(${rows}, var(--cell-size)) var(--cell-size)`;

        // --- Render Main Pattern Area and Row Headers (top to bottom) ---
        // Rows in chartData are 0-indexed (top to bottom). Displayed numbers are 1-indexed (bottom to top).
        // So, patternRowIndex (0 to rows-1) corresponds to displayedRow (rows to 1).
        // For displayed row 'r', the internal index is 'rows - r'.
        for (let rDisplay = rows; rDisplay >= 1; rDisplay--) {
            const patternRIdx = rows - rDisplay; // Convert display row to 0-indexed pattern row

            // Row Header (first column of this logical row)
            const rowHeader = document.createElement('div');
            rowHeader.classList.add('number-header');
            rowHeader.textContent = rDisplay; // Display r (1-indexed)
            containerElement.appendChild(rowHeader);

            // Pattern Cells for this row
            for (let cDisplay = 1; cDisplay <= cols; cDisplay++) { // Loop for columns (Left to Right for drawing)
                const patternCIdx = cDisplay - 1; // Convert display col to 0-indexed pattern col

                const cellDiv = document.createElement('div');
                cellDiv.classList.add('grid-cell');
                // Store 0-indexed row/col for internal data array reference
                cellDiv.dataset.patternRow = patternRIdx;
                cellDiv.dataset.patternCol = patternCIdx;

                if (enableEdit) {
                    cellDiv.classList.add('grid-cell-editable');
                    cellDiv.addEventListener('click', () => toggleCell(chartType, patternRIdx, patternCIdx));
                }

                // Set initial color for front/back charts based on their data
                if (chartType === 'front') {
                    cellDiv.classList.add(frontChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                } else if (chartType === 'back') {
                    cellDiv.classList.add(backChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                }
                // Combined chart cells will be updated by generateAndRenderCombinedChart after their initial render
                containerElement.appendChild(cellDiv);
            }
        }

        // --- Render Bottom Row: Blank Corner + Column Headers (right to left) ---
        // Blank bottom-left corner cell (occupies the space of the row number in the bottom row)
        const bottomLeftCornerDiv = document.createElement('div');
        bottomLeftCornerDiv.classList.add('corner-header');
        containerElement.appendChild(bottomLeftCornerDiv);

        // Column headers (Right to Left: cols, cols-1, ..., 1)
        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) { // Loop for columns (Right to Left for numbering)
            const colHeader = document.createElement('div');
            colHeader.classList.add('number-header');
            colHeader.textContent = cDisplay; // Display c (1-indexed)
            containerElement.appendChild(colHeader);
        }
    }

    function toggleCell(chartType, patternRIdx, patternCIdx) {
      console.log(`Toggling cell [${patternRIdx}, ${patternCIdx}] in ${chartType} chart.`);
      let targetChart;
      let targetElementId;

      if (chartType === 'front') {
        targetChart = frontChart;
        targetElementId = 'frontChartGrid';
      } else if (chartType === 'back') {
        targetChart = backChart;
        targetElementId = 'backChartGrid';
      }

      targetChart[patternRIdx][patternCIdx] = !targetChart[patternRIdx][patternCIdx];
      // Update the specific cell's color in the DOM
      const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${patternRIdx}"][data-pattern-col="${patternCIdx}"]`);
      if (cellDiv) {
          cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
          cellDiv.classList.add(targetChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
      }
      generateAndRenderCombinedChart();
    }

    function generateAndRenderCombinedChart() {
      console.log('Generating and rendering combined chart...');
      combinedChart = frontChart.map((frontRow, rIdx) =>
        frontRow.map((frontCell, cIdx) => {
          const backCell = backChart[rIdx][cIdx];

          if (frontCell && !backCell) { // Front Black, Back White
            return 'BW';
          } else if (!frontCell && backCell) { // Front White, Back Black
            return 'WB';
          } else if (frontCell && backCell) { // Both Black
            return 'BB';
          } else { // Both White
            return 'WW';
          }
        })
      );
      console.log('New Combined Chart Data (for DOM render):', combinedChart);

      combinedChart.forEach((row, rIdx) => { // rIdx, cIdx here are 0-indexed for pattern data
        row.forEach((cellValue, cIdx) => {
          // Find the specific cell by its data attributes
          const cellDiv = combinedChartGridElement.querySelector(`[data-pattern-row="${rIdx}"][data-pattern-col="${cIdx}"]`);
          if (cellDiv) {
            let backgroundColorClass = 'bg-gray-200';
            let dotContentHTML = '';

            if (cellValue === 'BB' || cellValue === 'BW') {
              backgroundColorClass = 'bg-black';
            } else if (cellValue === 'WW' || cellValue === 'WB') {
              backgroundColorClass = 'bg-white';
            }

            cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
            cellDiv.classList.add(backgroundColorClass);

            if (cellValue === 'BW') {
              dotContentHTML = '<span class="dot-container text-white">⚪</span>';
            } else if (cellValue === 'WB') {
              dotContentHTML = '<span class="dot-container text-black">⚫</span>';
            }
            cellDiv.innerHTML = dotContentHTML; // Set innerHTML with the dot span
          }
        });
      });
      console.log('Combined Chart rendered to DOM.');
    }

    function updateZoom(factor) {
        let newSize = currentCellSize + (factor * ZOOM_STEP);
        newSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, newSize));

        if (newSize !== currentCellSize) {
            currentCellSize = newSize;
            currentDotSize = Math.max(8, Math.round(currentCellSize / 2));
            currentDotFontSize = Math.max(0.5, currentCellSize / 32);
            currentNumberFontSize = `${Math.max(0.6, currentCellSize / 35)}rem`; // Adjust number font size

            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
            document.documentElement.style.setProperty('--dot-size', `${currentDotSize}px`);
            document.documentElement.style.setProperty('--dot-font-size', `${currentDotFontSize}rem`);
            document.documentElement.style.setProperty('--number-font-size', currentNumberFontSize);
        }

        // Re-render all charts to apply new cell size, dot, and number styles, preserving data
        renderChart(frontChart, 'frontChartGrid', true, 'front');
        renderChart(backChart, 'backChartGrid', true, 'back');
        renderChart(combinedChart, 'combinedChartGrid', false, 'combined'); // Explicitly render combined chart grid
        generateAndRenderCombinedChart(); // Re-render combined with current data
        console.log(`Zoom updated to cell size: ${currentCellSize}px, dot size: ${currentDotSize}px, font size: ${currentDotFontSize}rem, number font size: ${currentNumberFontSize}.`);
    }

    // Function to draw the combined chart onto a hidden canvas for precise image generation
    function drawCombinedChartToCanvas() {
        const canvas = document.createElement('canvas');
        const renderScale = 4; // Higher scale for better resolution
        const scaledCellSize = currentCellSize * renderScale;
        const scaledDotRadius = (currentDotSize / 2) * renderScale;
        const scaledNumberFontSizePx = parseFloat(currentNumberFontSize) * 16 * renderScale; // Convert rem to px and scale

        // Canvas dimensions need to account for the number row and column
        canvas.width = (cols + 1) * scaledCellSize; // +1 for the row number column on the left
        canvas.height = (rows + 1) * scaledCellSize; // +1 for the column number row at the bottom
        const ctx = canvas.getContext('2d');

        // Set font for numbers
        ctx.font = `${scaledNumberFontSizePx}px Inter`; // Use "Inter" font or a fallback
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#4b5563'; // gray-700 for numbers text

        // Draw Blank Top-Left Corner
        ctx.fillStyle = '#f3f4f6'; // background for numbers
        ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
        ctx.strokeStyle = '#9ca3af'; // border color
        ctx.lineWidth = 1 * renderScale;
        ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);

        // Draw Row Numbers (left-most column) - 1-indexed, Bottom to Top for display
        // Loop from the top-most pattern row (0-indexed) down to the bottom-most pattern row
        for (let rIdx = 0; rIdx < rows; rIdx++) {
            const rDisplay = rows - rIdx; // Convert 0-indexed pattern row to 1-indexed display row (bottom to top)
            const canvasY = rIdx * scaledCellSize; // Y position on canvas

            ctx.fillStyle = '#f3f4f6'; // bg-gray-100 for numbers background
            ctx.fillRect(0, canvasY, scaledCellSize, scaledCellSize); // Background for number cell
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(0, canvasY, scaledCellSize, scaledCellSize); // Border for number cell

            ctx.fillStyle = '#4b5563'; // Text color
            ctx.fillText(rDisplay.toString(), scaledCellSize / 2, canvasY + scaledCellSize / 2);
        }

        // Draw Pattern Cells (offset by 1 column for row numbers, and 0 for row offset as they fill top part)
        combinedChart.forEach((row, rIdx) => { // rIdx is 0-indexed pattern row (top to bottom)
            row.forEach((cellValue, cIdx) => { // cIdx is 0-indexed pattern col (left to right)
                const x = (cIdx + 1) * scaledCellSize; // Offset by one column for row numbers
                const y = rIdx * scaledCellSize; // Top-most rows for pattern data

                // Draw cell background
                if (cellValue === 'BB' || cellValue === 'BW') {
                    ctx.fillStyle = '#000'; // Black
                } else if (cellValue === 'WW' || cellValue === 'WB') {
                    ctx.fillStyle = '#fff'; // White
                } else {
                    ctx.fillStyle = '#e5e7eb'; // Gray fallback
                }
                ctx.fillRect(x, y, scaledCellSize, scaledCellSize);

                // Draw cell border
                ctx.strokeStyle = '#9ca3af'; // gray-400
                ctx.lineWidth = 1 * renderScale;
                ctx.strokeRect(x + ctx.lineWidth / 2, y + ctx.lineWidth / 2, scaledCellSize - ctx.lineWidth, scaledCellSize - ctx.lineWidth);

                // Draw solid circle dot if applicable (no stroke for solid look)
                if (cellValue === 'BW') { // Black background, White dot
                    ctx.fillStyle = '#fff'; // White dot color
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cellValue === 'WB') { // White background, Black dot
                    ctx.fillStyle = '#000'; // Black dot color
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });

        // Draw Column Numbers (bottom-most row) - 1-indexed, Right to Left for display
        const colNumbersY = rows * scaledCellSize; // Y position for the column number row
        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) {
            const canvasX = (cols - cDisplay + 1) * scaledCellSize; // X position on canvas (offset by 1 for row numbers)

            ctx.fillStyle = '#f3f4f6'; // bg-gray-100 for numbers background
            ctx.fillRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize); // Background for number cell
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize); // Border for number cell

            ctx.fillStyle = '#4b5563'; // Text color
            ctx.fillText(cDisplay.toString(), canvasX + scaledCellSize / 2, colNumbersY + scaledCellSize / 2);
        }

        return canvas;
    }

    function downloadCombinedChart() {
        showMessage('Generating image...', 1000);
        const canvas = drawCombinedChartToCanvas();
        const image = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = image;
        link.download = 'double-knitting-combined-chart.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showMessage('Chart downloaded successfully!');
        console.log('Combined chart downloaded.');
    }

    function copyCombinedChart() {
        showMessage('Copying image to clipboard...', 1000);
        const canvas = drawCombinedChartToCanvas();
        canvas.toBlob(function(blob) {
            if (navigator.clipboard && navigator.clipboard.write) {
                const item = new ClipboardItem({ "image/png": blob });
                navigator.clipboard.write([item])
                    .then(() => {
                        showMessage('Chart copied to clipboard!');
                        console.log('Combined chart copied to clipboard (Clipboard API).');
                    })
                    .catch(err => {
                        console.warn('Failed to copy to clipboard using Clipboard API:', err);
                        showMessage('Failed to copy chart to clipboard.');
                    });
            } else {
                showMessage('Your browser does not support direct image copy to clipboard. Please download and copy manually.', 5000);
                console.warn('Clipboard API not available. Fallback to execCommand will likely fail for images.');
            }
        }, 'image/png');
    }

    function restartCharts() {
        console.log('Restarting charts...');
        rowsInput.value = 20;
        colsInput.value = 20;
        rows = 20;
        cols = 20;
        currentCellSize = 24;
        currentDotSize = 12;
        currentDotFontSize = 0.75;
        currentNumberFontSize = '0.7rem'; // Reset number font size

        initializeChartData();
        updateZoom(0); // Trigger a full re-render with default settings and empty charts
        showMessage('Charts have been reset!');
    }

    function inverseChartColors(chartType) {
        let targetChart;
        let targetElementId;

        if (chartType === 'front') {
            targetChart = frontChart;
            targetElementId = 'frontChartGrid';
        } else if (chartType === 'back') {
            targetChart = backChart;
            targetElementId = 'backChartGrid';
        }

        // Inverse the data and update DOM
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                targetChart[r][c] = !targetChart[r][c];
                const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${r}"][data-pattern-col="${c}"]`);
                if (cellDiv) {
                    cellDiv.classList.remove('bg-black', 'bg-white', 'bg-gray-200');
                    cellDiv.classList.add(targetChart[r][c] ? 'bg-black' : 'bg-white');
                }
            }
        }
        generateAndRenderCombinedChart(); // Regenerate and re-render combined chart
        showMessage(`${chartType} chart colors inverted!`);
    }

    // Event listeners for dimension inputs
    rowsInput.addEventListener('change', (e) => {
      rows = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    colsInput.addEventListener('change', (e) => {
      cols = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    // Event listeners for zoom buttons
    zoomInBtn.addEventListener('click', () => updateZoom(1));
    zoomOutBtn.addEventListener('click', () => updateZoom(-1));

    // Event listeners for download/copy/restart buttons
    downloadChartBtn.addEventListener('click', downloadCombinedChart);
    copyChartBtn.addEventListener('click', copyCombinedChart);
    restartBtn.addEventListener('click', restartCharts);

    // Event listeners for inverse buttons
    inverseFrontBtn.addEventListener('click', () => inverseChartColors('front'));
    inverseBackBtn.addEventListener('click', () => inverseChartColors('back'));

    // Initial setup on window load
    window.onload = () => {
        rows = Math.max(1, parseInt(rowsInput.value));
        cols = Math.max(1, parseInt(colsInput.value));
        initializeChartData();
        updateZoom(0); // This will trigger the first full render
    };
  </script>
</body>
</html>
