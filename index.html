<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Double Knitting Pattern Generator</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- html2canvas CDN for converting the rendered HTML to image (for download/copy) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- jsPDF CDN for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Chosen Palette: Nature Walk Palette (Earthy Tones) -->
  <!-- Application Structure Plan: The application uses a three-column dashboard-like structure for its main content (Front Chart, Back Chart, Combined Chart). This allows users to simultaneously view their input patterns and the generated output, fostering direct comparison and immediate feedback. Controls for dimensions, zoom, and chart actions are positioned at the top for easy access. This structure was chosen for its intuitive visual flow, enabling users to easily explore the interactive data (pattern toggling) and synthesize the results (combined chart). -->
  <!-- Visualization & Content Choices:
    - Report Info -> Goal -> Viz/Presentation Method -> Interaction -> Justification -> Library/Method
    - Chart Data -> Inform/Design -> Interactive Grids (HTML Divs with dynamic classes) -> Cell click to toggle color -> Direct manipulation, visual feedback -> Vanilla JS
    - Combined Pattern Logic -> Inform/Synthesize -> Combined Chart (HTML Divs with dynamic classes and nested spans for dots) -> Auto-generated on input change -> Immediate visualization of complex logic -> Vanilla JS
    - Pattern Control -> Control -> Numeric Inputs (HTML Input) -> Input change for dimension update -> Precise control over grid size -> Vanilla JS
    - Zoom Control -> Explore/Context -> Buttons (HTML Button) -> Click to adjust cell size -> Adaptability for detail/overview -> Vanilla JS, CSS Variables
    - Image Download/Copy -> Output -> Buttons (HTML Button) -> Click to save/copy image -> User utility, sharing -> Canvas API (for dots), html2canvas (for overall capture)
    - Restart -> Control -> Button (HTML Button) -> Click to reset patterns -> User convenience -> Vanilla JS
    - Chart Labeling -> Inform -> Column/Row Numbers (HTML Divs/Spans directly in grid) -> Dynamically rendered, respond to zoom -> Improved clarity for knitting patterns (right-to-left for cols at bottom, bottom-to-top for rows) -> Vanilla JS
    - Written Instructions -> Inform/Action -> Text area (HTML Div) & Buttons (HTML Button) -> Click to generate/download text or combined document -> Provides alternative pattern format -> Vanilla JS
    - Information Architecture is designed to be highly interactive and task-oriented, allowing direct manipulation of input and immediate viewing of output.
  -->
  <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    /* Hide scrollbar for grid containers */
    .overflow-y-auto::-webkit-scrollbar {
      display: none;
    }
    .overflow-y-auto {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    /* Custom styles for grid cells - initial size will be set by JS */
    :root {
        --cell-size: 24px; /* Default cell size */
        --dot-size: 12px; /* Default dot size, half of cell-size */
        --dot-font-size: 0.75rem; /* text-xs for dots */
        --number-font-size: 0.7rem; /* Font size for row/col numbers */
    }
    .grid-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid #A19E92; /* Subtle grey-green-brown */
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-sizing: border-box;
      overflow: hidden;
    }
    .grid-cell-editable:hover {
      opacity: 0.75;
      cursor: pointer;
    }
    /* Chart cells are now pure black/white */
    .bg-black { background-color: #000; }
    .bg-white { background-color: #fff; }
    .text-black { color: #000; }
    .text-white { color: #fff; }


    /* Styles for the message box */
    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #4F6B4D; /* Deep forest green */
        color: #FCFCF8; /* Off-white */
        padding: 15px 30px;
        border-radius: 8px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        font-weight: 600;
        text-align: center;
    }
    .message-box.show {
        opacity: 1;
    }

    /* Improved centering for dots using absolute positioning */
    .grid-cell .dot-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: var(--dot-size);
        height: var(--dot-size);
        line-height: var(--dot-size);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 9999px;
        border: 1px solid #A19E92; /* Subtle grey-green-brown */
        font-size: var(--dot-font-size);
        box-sizing: border-box;
    }

    /* Styles for number headers */
    .number-header {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--number-font-size);
        color: #6B7F6C; /* Medium forest green */
        font-weight: 600;
        box-sizing: border-box;
    }
    /* Specific styling for the top-left blank corner of the grid */
    .corner-header {
      width: var(--cell-size);
      height: var(--cell-size);
    }
    .chart-grid-container {
      display: grid;
      gap: 1px;
      background-color: #C6B2A8; /* Muted rosy brown */
      border-radius: 2px;
      max-height: 400px;
      overflow: auto;
      overflow-y: auto;
      overflow-x: auto;
    }
    /* Hide scrollbar for the specific grid containers */
    .chart-grid-container::-webkit-scrollbar {
        display: none;
    }
    .chart-grid-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }

    /* Styles for Written Instructions Output */
    #writtenInstructionsOutput {
        white-space: pre-wrap;
        font-family: 'Courier New', Courier, monospace;
        background-color: #FCFCF8; /* Off-white */
        border: 1px solid #A19E92; /* Subtle grey-green-brown */
        border-radius: 0.5rem;
        padding: 1.5rem;
        margin-top: 2.5rem;
        max-width: 42rem;
        margin-left: auto;
        margin-right: auto;
        color: #4F6B4D; /* Deep forest green */
        font-size: 0.875rem;
        line-height: 1.5;
        overflow-x: auto;
        min-height: 50px;
    }
    /* Header banner style */
    .header-banner {
      background-color: #88AA80; /* Muted sage green */
      padding: 1.5rem 0; /* py-6 */
      margin-bottom: 2.5rem; /* mb-10 */
      border-radius: 0.5rem; /* rounded-lg */
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* shadow-md */
      text-align: center;
    }
  </style>
</head>
<body class="min-h-screen bg-[#E0EEDA] p-8 font-inter text-[#4F6B4D]">
  <!-- Header Banner -->
  <div class="header-banner">
    <h1 class="text-4xl font-bold text-[#3D4C3A] drop-shadow-lg">
      Double Knitting Pattern Generator
    </h1>
  </div>


  <!-- Global Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mb-8 space-y-4 md:space-y-0 md:space-x-4">
    <!-- Grid Dimension Controls -->
    <div class="flex items-center space-x-4">
      <label for="rows" class="font-medium text-lg">Rows:</label>
      <input
        type="number"
        id="rows"
        value="20"
        min="1"
        class="w-20 p-2 border border-[#A19E92] rounded-md shadow-sm focus:ring-[#D98A5B] focus:border-[#D98A5B]"
      />
      <label for="cols" class="font-medium text-lg">Columns:</label>
      <input
        type="number"
        id="cols"
        value="20"
        min="1"
        class="w-20 p-2 border border-[#A19E92] rounded-md shadow-sm focus:ring-[#D98A5B] focus:border-[#D98A5B]"
      />
    </div>

    <!-- Zoom Controls -->
    <div class="flex items-center space-x-4">
      <span class="font-medium text-lg">Zoom:</span>
      <button id="zoomOutBtn" class="px-4 py-2 bg-[#D98A5B] text-white rounded-md shadow-md hover:bg-[#C97A4B] focus:outline-none focus:ring-2 focus:ring-[#D98A5B] focus:ring-opacity-75">
        Zoom Out
      </button>
      <button id="zoomInBtn" class="px-4 py-2 bg-[#D98A5B] text-white rounded-md shadow-md hover:bg-[#C97A4B] focus:outline-none focus:ring-2 focus:ring-[#D98A5B] focus:ring-opacity-75">
        Zoom In
      </button>
    </div>
  </div>

  <!-- Chart Display Area -->
  <div class="flex flex-wrap justify-center items-start">
    <!-- Front Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-[#FCFCF8] rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-[#4F6B4D]">Front Chart (Click to toggle color)</h3>
      <div id="frontChartGrid" class="chart-grid-container"></div>
      <button id="inverseFrontBtn" class="mt-4 px-4 py-2 bg-[#88AA80] text-white rounded-md shadow-md hover:bg-[#789A70] focus:outline-none focus:ring-2 focus:ring-[#88AA80] focus:ring-opacity-75">
        Inverse Front Colors
      </button>
    </div>

    <!-- Back Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-[#FCFCF8] rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-[#4F6B4D]">Back Chart (Click to toggle color)</h3>
      <div id="backChartGrid" class="chart-grid-container"></div>
      <button id="inverseBackBtn" class="mt-4 px-4 py-2 bg-[#88AA80] text-white rounded-md shadow-md hover:bg-[#789A70] focus:outline-none focus:ring-2 focus:ring-[#88AA80] focus:ring-opacity-75">
        Inverse Back Colors
      </button>
    </div>

    <!-- Combined Chart Container -->
    <div class="chart-wrapper flex flex-col items-center p-4 bg-[#FCFCF8] rounded-lg shadow-md m-4">
      <h3 class="text-xl font-semibold mb-4 text-[#4F6B4D]">Combined Chart (Read-Only)</h3>
      <div id="combinedChartGrid" class="chart-grid-container"></div>
    </div>
  </div>

  <!-- Optional Title Input -->
  <div class="flex justify-center items-center mb-8 space-x-4">
    <label for="patternTitleInput" class="font-medium text-lg">Pattern Title (Optional):</label>
    <input
      type="text"
      id="patternTitleInput"
      placeholder="e.g., My Custom Pattern"
      class="w-64 p-2 border border-[#A19E92] rounded-md shadow-sm focus:ring-[#D98A5B] focus:border-[#D98A5B]"
    />
  </div>

  <!-- Action Controls -->
  <div class="flex flex-col md:flex-row justify-center items-center mt-8 space-y-4 md:space-y-0 md:space-x-4">
    <button id="generateInstructionsBtn" class="px-6 py-3 bg-[#6A8D60] text-white font-semibold rounded-md shadow-md hover:bg-[#5B7A50] focus:outline-none focus:ring-2 focus:ring-[#6A8D60] focus:ring-opacity-75 transition duration-150 ease-in-out">
      Generate Written Instructions
    </button>
    <button id="downloadInstructionsBtn" class="px-6 py-3 bg-[#A19E92] text-white font-semibold rounded-md shadow-md hover:bg-[#918E82] focus:outline-none focus:ring-2 focus:ring-[#A19E92] focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Written Instructions (PDF)
    </button>
    <button id="downloadCombinedDocumentBtn" class="px-6 py-3 bg-[#C2A79D] text-white font-semibold rounded-md shadow-md hover:bg-[#B2978D] focus:outline-none focus:ring-2 focus:ring-[#C2A79D] focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Full Pattern (PDF)
    </button>
    <button id="downloadChartBtn" class="px-6 py-3 bg-[#D98A5B] text-white font-semibold rounded-md shadow-md hover:bg-[#C97A4B] focus:outline-none focus:ring-2 focus:ring-[#D98A5B] focus:ring-opacity-75 transition duration-150 ease-in-out">
      Download Combined Chart (PDF)
    </button>
    <button id="restartBtn" class="px-6 py-3 bg-[#CC7070] text-white font-semibold rounded-md shadow-md hover:bg-[#BC6060] focus:outline-none focus:ring-2 focus:ring-[#CC7070] focus:ring-opacity-75 transition duration-150 ease-in-out">
      Restart Charts
    </button>
  </div>

  <!-- Written Instructions Output Area -->
  <div id="writtenInstructionsOutput" class="hidden">
    <h3 class="text-xl font-semibold mb-4 text-[#4F6B4D]">Generated Written Instructions:</h3>
    <pre id="instructionsText" class="text-sm text-[#4F6B4D]"></pre>
    <p class="mt-4 text-[#6B7F6C]">
      <strong>Instructions Legend:</strong><br>
      - "KB/PW": Knit Black on Front, Purl White on Back.<br>
      - "KW/PB": Knit White on Front, Purl Black on Back.<br>
      - "KBB": Knit Black on Both Front and Back.<br>
      - "KWW": Knit White on Both Front and Back.
    </p>
  </div>

  <div class="text-center mt-10 p-4 bg-[#FCFCF8] rounded-lg shadow-lg max-w-2xl mx-auto">
    <h2 class="text-2xl font-semibold mb-4 text-[#4F6B4D]">Understanding the Combined Chart:</h2>
    <p class="text-[#6B7F6C] mb-2">
      This version of the combined chart uses simple color codes:
    </p>
    <ul class="list-disc list-inside text-left text-[#6B7F6C] mx-auto w-fit">
      <li><span class="inline-block w-4 h-4 bg-black border border-[#A19E92] rounded-sm mr-2 align-middle"></span><span class="font-medium">Black cell with White dot (⚪):</span> Front is Black, Back is White. (e.g., Knit with Black yarn, Purl with White yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-[#A19E92] rounded-sm mr-2 align-middle"></span><span class="font-medium">White cell with Black dot (⚫):</span> Front is White, Back is Black. (e.g., Knit with White yarn, Purl with Black yarn)</li>
      <li><span class="inline-block w-4 h-4 bg-black border border-[#A19E92] rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure Black cell:</span> Both Front and Back are Black. (e.g., Knit with Black, Purl with Black)</li>
      <li><span class="inline-block w-4 h-4 bg-white border border-[#A19E92] rounded-sm mr-2 align-middle"></span><span class="font-medium">Pure White cell:</span> Both Front and Back are White. (e.g., Knit with White, Purl with White)</li>
    </ul>
    <p class="text-[#6B7F6C] mt-4">
      The dot representation on the combined chart clarifies the individual knit and purl stitches when the front and back patterns differ.
    </p>
  </div>

  <!-- Message box for copy/download feedback -->
  <div id="messageBox" class="message-box hidden"></div>

  <script>
    let rows = 20;
    let cols = 20;
    let frontChart = [];
    let backChart = [];
    let combinedChart = [];
    let currentCellSize = 24;
    let currentDotSize = 12;
    let currentDotFontSize = 0.75;
    let currentNumberFontSize = '0.7rem';

    // Define custom color variables for easier management and consistency
    const COLOR_BLACK_CUSTOM = '#000'; // Pure Black
    const COLOR_WHITE_CUSTOM = '#fff'; // Pure White
    const COLOR_GRID_BORDER = '#A19E92'; // Subtle grey-green-brown for cell borders
    const COLOR_NUMBER_TEXT = '#6B7F6C'; // Medium forest green for number text
    const COLOR_GRID_BACKGROUND = '#C6B2A8'; // Muted rosy brown for grid background
    const COLOR_CORNER_HEADER = '#E0EEDA'; // Light green-beige for corner headers / background of numbers

    const MIN_CELL_SIZE = 8;
    const MAX_CELL_SIZE = 60;
    const ZOOM_STEP = 4;

    const frontChartGridElement = document.getElementById('frontChartGrid');
    const backChartGridElement = document.getElementById('backChartGrid');
    const combinedChartGridElement = document.getElementById('combinedChartGrid');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const downloadChartBtn = document.getElementById('downloadChartBtn');
    const restartBtn = document.getElementById('restartBtn');
    const inverseFrontBtn = document.getElementById('inverseFrontBtn');
    const inverseBackBtn = document.getElementById('inverseBackBtn');
    const generateInstructionsBtn = document.getElementById('generateInstructionsBtn');
    const downloadInstructionsBtn = document.getElementById('downloadInstructionsBtn');
    const downloadCombinedDocumentBtn = document.getElementById('downloadCombinedDocumentBtn');
    const writtenInstructionsOutput = document.getElementById('writtenInstructionsOutput');
    const instructionsText = document.getElementById('instructionsText');
    const patternTitleInput = document.getElementById('patternTitleInput');
    const messageBox = document.getElementById('messageBox');

    const { jsPDF } = window.jspdf;

    function showMessage(message, duration = 3000) {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden');
        messageBox.classList.add('show');
        setTimeout(() => {
            messageBox.classList.remove('show');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 500);
        }, duration);
    }

    function createEmptyChart(r, c, startBlack = false) {
      return Array(r).fill(null).map(() => Array(c).fill(startBlack));
    }

    function initializeChartData() {
        frontChart = createEmptyChart(rows, cols, false);
        backChart = createEmptyChart(rows, cols, true);
        console.log('Chart data initialized.');
    }

    function renderChart(chartData, containerElementId, enableEdit, chartType) {
        const containerElement = document.getElementById(containerElementId);
        containerElement.innerHTML = '';

        containerElement.style.gridTemplateColumns = `var(--cell-size) repeat(${cols}, var(--cell-size))`;
        containerElement.style.gridTemplateRows = `repeat(${rows}, var(--cell-size)) var(--cell-size)`;

        for (let rDisplay = rows; rDisplay >= 1; rDisplay--) {
            const patternRIdx = rows - rDisplay;

            const rowHeader = document.createElement('div');
            rowHeader.classList.add('number-header');
            rowHeader.textContent = rDisplay;
            containerElement.appendChild(rowHeader);

            for (let cDisplay = 1; cDisplay <= cols; cDisplay++) {
                const patternCIdx = cDisplay - 1;

                const cellDiv = document.createElement('div');
                cellDiv.classList.add('grid-cell');
                cellDiv.dataset.patternRow = patternRIdx;
                cellDiv.dataset.patternCol = patternCIdx;

                if (enableEdit) {
                    cellDiv.classList.add('grid-cell-editable');
                    cellDiv.addEventListener('click', () => toggleCell(chartType, patternRIdx, patternCIdx));
                }

                // Use pure black/white for chart rendering
                if (chartType === 'front') {
                    cellDiv.classList.add(frontChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                } else if (chartType === 'back') {
                    cellDiv.classList.add(backChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
                }
                containerElement.appendChild(cellDiv);
            }
        }

        const bottomLeftCornerDiv = document.createElement('div');
        bottomLeftCornerDiv.classList.add('corner-header');
        containerElement.appendChild(bottomLeftCornerDiv);

        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) {
            const colHeader = document.createElement('div');
            colHeader.classList.add('number-header');
            colHeader.textContent = cDisplay;
            containerElement.appendChild(colHeader);
        }
    }

    function toggleCell(chartType, patternRIdx, patternCIdx) {
      console.log(`Toggling cell [${patternRIdx}, ${patternCIdx}] in ${chartType} chart.`);
      let targetChart;
      let targetElementId;

      if (chartType === 'front') {
        targetChart = frontChart;
        targetElementId = 'frontChartGrid';
      } else if (chartType === 'back') {
        targetChart = backChart;
        targetElementId = 'backChartGrid';
      }

      targetChart[patternRIdx][patternCIdx] = !targetChart[patternRIdx][patternCIdx];
      const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${patternRIdx}"][data-pattern-col="${patternCIdx}"]`);
      if (cellDiv) {
          // Use pure black/white for chart rendering
          cellDiv.classList.remove('bg-black', 'bg-white');
          cellDiv.classList.add(targetChart[patternRIdx][patternCIdx] ? 'bg-black' : 'bg-white');
      }
      generateAndRenderCombinedChart();
    }

    function generateAndRenderCombinedChart() {
      console.log('Generating and rendering combined chart...');
      combinedChart = frontChart.map((frontRow, rIdx) =>
        frontRow.map((frontCell, cIdx) => {
          const backCell = backChart[rIdx][cIdx];

          if (frontCell && !backCell) {
            return 'BW';
          } else if (!frontCell && backCell) {
            return 'WB';
          } else if (frontCell && backCell) {
            return 'BB';
          } else {
            return 'WW';
          }
        })
      );
      console.log('New Combined Chart Data (for DOM render):', combinedChart);

      combinedChart.forEach((row, rIdx) => {
        row.forEach((cellValue, cIdx) => {
          const cellDiv = combinedChartGridElement.querySelector(`[data-pattern-row="${rIdx}"][data-pattern-col="${cIdx}"]`);
          if (cellDiv) {
            let backgroundColorClass = '';
            let dotContentHTML = '';

            // Use pure black/white for chart rendering
            if (cellValue === 'BB' || cellValue === 'BW') {
              backgroundColorClass = 'bg-black';
            } else if (cellValue === 'WW' || cellValue === 'WB') {
              backgroundColorClass = 'bg-white';
            }

            cellDiv.classList.remove('bg-black', 'bg-white');
            cellDiv.classList.add(backgroundColorClass);

            // Use pure black/white for dot colors
            if (cellValue === 'BW') {
              dotContentHTML = `<span class="dot-container text-white">⚪</span>`;
            } else if (cellValue === 'WB') {
              dotContentHTML = `<span class="dot-container text-black">⚫</span>`;
            }
            cellDiv.innerHTML = dotContentHTML;
          }
        });
      });
      console.log('Combined Chart rendered to DOM.');
    }

    function updateZoom(factor) {
        let newSize = currentCellSize + (factor * ZOOM_STEP);
        newSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, newSize));

        if (newSize !== currentCellSize) {
            currentCellSize = newSize;
            currentDotSize = Math.max(8, Math.round(currentCellSize / 2));
            currentDotFontSize = Math.max(0.5, currentCellSize / 32);
            currentNumberFontSize = `${Math.max(0.6, currentCellSize / 35)}rem`;

            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
            document.documentElement.style.setProperty('--dot-size', `${currentDotSize}px`);
            document.documentElement.style.setProperty('--dot-font-size', `${currentDotFontSize}rem`);
            document.documentElement.style.setProperty('--number-font-size', currentNumberFontSize);
        }

        renderChart(frontChart, 'frontChartGrid', true, 'front');
        renderChart(backChart, 'backChartGrid', true, 'back');
        renderChart(combinedChart, 'combinedChartGrid', false, 'combined');
        generateAndRenderCombinedChart();
        console.log(`Zoom updated to cell size: ${currentCellSize}px, dot size: ${currentDotSize}px, font size: ${currentDotFontSize}rem, number font size: ${currentNumberFontSize}.`);
    }

    function drawCombinedChartToCanvas() {
        const canvas = document.createElement('canvas');
        const renderScale = 4;
        const scaledCellSize = currentCellSize * renderScale;
        const scaledDotRadius = (currentDotSize / 2) * renderScale;
        const scaledNumberFontSizePx = parseFloat(currentNumberFontSize) * 16 * renderScale;

        canvas.width = (cols + 1) * scaledCellSize;
        canvas.height = (rows + 1) * scaledCellSize;
        const ctx = canvas.getContext('2d');

        ctx.font = `${scaledNumberFontSizePx}px Inter`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = COLOR_NUMBER_TEXT;

        // Draw Blank Top-Left Corner
        ctx.fillStyle = COLOR_CORNER_HEADER;
        ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
        ctx.strokeStyle = COLOR_GRID_BORDER;
        ctx.lineWidth = 1 * renderScale;
        ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);

        // Draw Row Numbers (left-most column)
        for (let rIdx = 0; rIdx < rows; rIdx++) {
            const rDisplay = rows - rIdx;
            const canvasY = rIdx * scaledCellSize;

            ctx.fillStyle = COLOR_CORNER_HEADER;
            ctx.fillRect(0, canvasY, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = COLOR_GRID_BORDER;
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(0, canvasY, scaledCellSize, scaledCellSize);

            ctx.fillStyle = COLOR_NUMBER_TEXT;
            ctx.fillText(rDisplay.toString(), scaledCellSize / 2, canvasY + scaledCellSize / 2);
        }

        // Draw Pattern Cells
        combinedChart.forEach((row, rIdx) => {
            row.forEach((cellValue, cIdx) => {
                const x = (cIdx + 1) * scaledCellSize;
                const y = rIdx * scaledCellSize;

                if (cellValue === 'BB' || cellValue === 'BW') {
                    ctx.fillStyle = COLOR_BLACK_CUSTOM; // Use #000
                } else if (cellValue === 'WW' || cellValue === 'WB') {
                    ctx.fillStyle = COLOR_WHITE_CUSTOM; // Use #fff
                } else {
                    ctx.fillStyle = '#e5e7eb'; // Fallback for unexpected values
                }
                ctx.fillRect(x, y, scaledCellSize, scaledCellSize);

                ctx.strokeStyle = COLOR_GRID_BORDER;
                ctx.lineWidth = 1 * renderScale;
                ctx.strokeRect(x + ctx.lineWidth / 2, y + ctx.lineWidth / 2, scaledCellSize - ctx.lineWidth, scaledCellSize - ctx.lineWidth);

                if (cellValue === 'BW') {
                    ctx.fillStyle = COLOR_WHITE_CUSTOM; // Use #fff for white dot
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cellValue === 'WB') {
                    ctx.fillStyle = COLOR_BLACK_CUSTOM; // Use #000 for black dot
                    ctx.beginPath();
                    const dotCenterX = x + scaledCellSize / 2;
                    const dotCenterY = y + scaledCellSize / 2;
                    ctx.arc(dotCenterX, dotCenterY, scaledDotRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });

        // Draw Column Numbers (bottom-most row)
        const colNumbersY = rows * scaledCellSize;
        for (let cDisplay = cols; cDisplay >= 1; cDisplay--) {
            const canvasX = (cols - cDisplay + 1) * scaledCellSize;

            ctx.fillStyle = COLOR_CORNER_HEADER;
            ctx.fillRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = COLOR_GRID_BORDER;
            ctx.lineWidth = 1 * renderScale;
            ctx.strokeRect(canvasX, colNumbersY, scaledCellSize, scaledCellSize);

            ctx.fillStyle = COLOR_NUMBER_TEXT;
            ctx.fillText(cDisplay.toString(), canvasX + scaledCellSize / 2, colNumbersY + scaledCellSize / 2);
        }

        return canvas;
    }

    async function downloadCombinedChartPDF() {
        showMessage('Generating chart PDF...', 1000);
        const canvas = drawCombinedChartToCanvas();
        const imgData = canvas.toDataURL('image/png');
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF('landscape', 'pt', 'a4');
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = doc.internal.pageSize.getHeight();
        let currentY = 20;

        if (title) {
            doc.setFontSize(18);
            doc.setTextColor('#3D4C3A'); // Darker forest green for titles
            doc.text(title, pdfWidth / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        doc.setFontSize(14);
        doc.setTextColor('#3D4C3A'); // Darker forest green
        doc.text("Double Knitting Combined Chart", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;

        const imgProps= doc.getImageProperties(imgData);
        const imgRatio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth * 0.9;
        let imgHeight = imgWidth / imgRatio;

        if (imgHeight > (pdfHeight - currentY - 20)) {
            imgHeight = pdfHeight - currentY - 20;
            imgWidth = imgHeight * imgRatio;
        }

        const xOffset = (pdfWidth - imgWidth) / 2;

        doc.addImage(imgData, 'PNG', xOffset, currentY, imgWidth, imgHeight);
        doc.save('double-knitting-combined-chart.pdf');
        showMessage('Chart PDF downloaded successfully!');
        console.log('Combined chart PDF downloaded.');
    }

    function generateWrittenInstructions() {
        let instructions = "Double Knitting Pattern Instructions:\n\n";
        instructions += `Chart Size: ${rows} Rows x ${cols} Columns\n\n`;

        for (let rIdx = 0; rIdx < rows; rIdx++) {
            const rDisplay = rIdx + 1;
            instructions += `Row ${rDisplay}: `;

            let rowInstructions = [];
            for (let cIdx = 0; cIdx < cols; cIdx++) {
                const cellValue = combinedChart[rIdx][cIdx];
                switch (cellValue) {
                    case 'BW':
                        rowInstructions.push("KB/PW");
                        break;
                    case 'WB':
                        rowInstructions.push("KW/PB");
                        break;
                    case 'BB':
                        rowInstructions.push("KBB");
                        break;
                    case 'WW':
                        rowInstructions.push("KWW");
                        break;
                }
            }
            instructions += rowInstructions.join(", ") + ".\n";
        }

        instructionsText.textContent = instructions;
        writtenInstructionsOutput.classList.remove('hidden');
        showMessage('Instructions generated!');
        return instructions;
    }

    async function downloadWrittenInstructionsPDF() {
        showMessage('Generating instructions PDF...', 1000);
        const instructions = generateWrittenInstructions();
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF();
        let currentY = 20;

        doc.setFont('helvetica', 'normal');
        doc.setTextColor('#3D4C3A'); // Darker forest green

        if (title) {
            doc.setFontSize(18);
            doc.text(title, doc.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        doc.setFontSize(14);
        doc.text("Written Double Knitting Instructions", doc.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
        currentY += 20;

        doc.setFontSize(10);
        const textLines = doc.splitTextToSize(instructions, doc.internal.pageSize.getWidth() - 20);
        doc.text(textLines, 10, currentY);

        currentY += (textLines.length * 10) + 10;

        doc.setFontSize(10);
        doc.text("Instructions Legend:", 10, currentY);
        currentY += 15;
        doc.text("- KB/PW: Knit Black on Front, Purl White on Back.", 15, currentY);
        currentY += 10;
        doc.text("- KW/PB: Knit White on Front, Purl Black on Back.", 15, currentY);
        currentY += 10;
        doc.text("- KBB: Knit Black on Both Front and Back.", 15, currentY);
        currentY += 10;
        doc.text("- KWW: Knit White on Both Front and Back.", 15, currentY);


        doc.save('double-knitting-instructions.pdf');
        showMessage('Instructions PDF downloaded successfully!');
        console.log('Instructions PDF downloaded.');
    }

    async function downloadCombinedPatternDocumentPDF() {
        showMessage('Generating full pattern PDF...', 1000);

        const canvas = drawCombinedChartToCanvas();
        const imageUrl = canvas.toDataURL('image/png');

        const instructions = generateWrittenInstructions();
        const title = patternTitleInput.value.trim();

        const doc = new jsPDF('portrait', 'pt', 'a4');
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = doc.internal.pageSize.getHeight();
        const margin = 36;
        let currentY = margin;

        doc.setFont('helvetica', 'normal');
        doc.setTextColor('#3D4C3A'); // Darker forest green

        // Add Title
        if (title) {
            doc.setFontSize(18);
            doc.text(title, pdfWidth / 2, currentY, { align: 'center' });
            currentY += 30;
        }

        // Add Main Heading for the document
        doc.setFontSize(14);
        doc.text("Double Knitting Pattern: Visual Chart & Written Instructions", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 40;

        // Add Chart Section Heading and Description
        doc.setFontSize(16);
        doc.text("Combined Pattern Chart", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;
        doc.setFontSize(10);
        doc.text("This chart includes row numbers (left, bottom-to-top) and column numbers (bottom, right-to-left).", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 15;

        // Add Chart Image
        const imgProps = doc.getImageProperties(imageUrl);
        const imgRatio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth - (2 * margin);
        let imgHeight = imgWidth / imgRatio;

        const maxImgHeight = pdfHeight - currentY - margin - (doc.getFontSize() * 5);
        if (imgHeight > maxImgHeight) {
            imgHeight = maxImgHeight;
            imgWidth = imgHeight * imgRatio;
        }

        const imgX = (pdfWidth - imgWidth) / 2;
        doc.addImage(imageUrl, 'PNG', imgX, currentY, imgWidth, imgHeight);
        currentY += imgHeight + 30;

        // Add Written Instructions Section Heading
        if (currentY + 20 > pdfHeight - margin) {
            doc.addPage();
            currentY = margin;
        }
        doc.setFontSize(16);
        doc.text("Written Instructions", pdfWidth / 2, currentY, { align: 'center' });
        currentY += 20;

        // Add Instructions Text
        doc.setFontSize(10);
        const textLines = doc.splitTextToSize(instructions, pdfWidth - (2 * margin));
        
        for (let i = 0; i < textLines.length; i++) {
            if (currentY + doc.getLineHeight() > pdfHeight - margin) {
                doc.addPage();
                currentY = margin;
            }
            doc.text(textLines[i], margin, currentY);
            currentY += doc.getLineHeight();
        }
        currentY += 10;

        // Add Instructions Legend
        if (currentY + 60 > pdfHeight - margin) {
            doc.addPage();
            currentY = margin;
        }
        doc.setFontSize(10);
        doc.text("Instructions Legend:", margin, currentY);
        currentY += 15;
        doc.text("- KB/PW: Knit Black on Front, Purl White on Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KW/PB: Knit White on Front, Purl Black on Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KBB: Knit Black on Both Front and Back.", margin + 5, currentY);
        currentY += 10;
        doc.text("- KWW: Knit White on Both Front and Back.", margin + 5, currentY);
        
        doc.save('double-knitting-full-pattern.pdf');
        showMessage('Full pattern PDF downloaded successfully!');
        console.log('Full pattern PDF downloaded.');
    }

    function restartCharts() {
        console.log('Restarting charts...');
        rowsInput.value = 20;
        colsInput.value = 20;
        rows = 20;
        cols = 20;
        currentCellSize = 24;
        currentDotSize = 12;
        currentDotFontSize = 0.75;
        currentNumberFontSize = '0.7rem';
        patternTitleInput.value = '';

        initializeChartData();
        updateZoom(0);
        writtenInstructionsOutput.classList.add('hidden');
        showMessage('Charts have been reset!');
    }

    function inverseChartColors(chartType) {
        let targetChart;
        let targetElementId;

        if (chartType === 'front') {
            targetChart = frontChart;
            targetElementId = 'frontChartGrid';
        } else if (chartType === 'back') {
            targetChart = backChart;
            targetElementId = 'backChartGrid';
        }

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                targetChart[r][c] = !targetChart[r][c];
                const cellDiv = document.getElementById(targetElementId).querySelector(`[data-pattern-row="${r}"][data-pattern-col="${c}"]`);
                if (cellDiv) {
                    // Use pure black/white for chart rendering
                    cellDiv.classList.remove('bg-black', 'bg-white');
                    cellDiv.classList.add(targetChart[r][c] ? 'bg-black' : 'bg-white');
                }
            }
        }
        generateAndRenderCombinedChart();
        showMessage(`${chartType} chart colors inverted!`);
    }

    // Event listeners
    rowsInput.addEventListener('change', (e) => {
      rows = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    colsInput.addEventListener('change', (e) => {
      cols = Math.max(1, parseInt(e.target.value));
      initializeChartData();
      updateZoom(0);
    });

    zoomInBtn.addEventListener('click', () => updateZoom(1));
    zoomOutBtn.addEventListener('click', () => updateZoom(-1));
    downloadChartBtn.addEventListener('click', downloadCombinedChartPDF);
    restartBtn.addEventListener('click', restartCharts);
    inverseFrontBtn.addEventListener('click', () => inverseChartColors('front'));
    inverseBackBtn.addEventListener('click', () => inverseChartColors('back'));
    generateInstructionsBtn.addEventListener('click', generateWrittenInstructions);
    downloadInstructionsBtn.addEventListener('click', downloadWrittenInstructionsPDF);
    downloadCombinedDocumentBtn.addEventListener('click', downloadCombinedPatternDocumentPDF);


    // Initial setup on window load
    window.onload = () => {
        rows = Math.max(1, parseInt(rowsInput.value));
        cols = Math.max(1, parseInt(colsInput.value));
        initializeChartData();
        updateZoom(0);
    };
  </script>
</body>
</html>
